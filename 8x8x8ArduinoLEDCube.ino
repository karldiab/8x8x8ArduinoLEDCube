
#include <SPI.h>// SPI Library used to clock data out to the shift registers
#include <string.h>
#include <MatrixMath.h>
#include <avr/pgmspace.h>

#define latch_pin 4// Defines actual BIT of PortD for latch - is Arduino UNO pin 2, MEGA pin 4
#define blank_pin 5// Defines actual BIT of PortD for blank - is Arduino UNO pin 3, MEGA pin 5
#define data_pin 51// used by SPI, must be pin MOSI 11 on Arduino UNO, 51 on MEGA
#define clock_pin 52// used by SPI, must be 13 SCK 13 on Arduino UNO, 52 on MEGA

/* *** these assign layers to their digital pin numbers - all other programming should use these definitions
Added by SuperTech-IT for parallel layer data output to conform to RGB LED Cube PCB */
#define layer1 4 // bottom layer
#define layer2 5
#define layer3 6
#define layer4 7
#define layer5 8
#define layer6 9
#define layer7 10
#define layer8 11 // top layer
int layerArray[8] = {layer1,layer2,layer3,layer4,layer5,layer6,layer7,layer8};
int lastAnode;
// End of Layer Definitions for SuperTech-IT board



// define some values used by the panel and buttons
#define btnRIGHT  0
#define btnUP     1
#define btnDOWN   2
#define btnLEFT   3
#define btnSELECT 4
#define btnNONE   5
#define numberOfRoutines 14
//This holds the settings for each routine, there are 4 different settings, which each setting does it decided by the routine itself
int routineSettings[numberOfRoutines][4];
char* settingNames[4] = {"A", "B", "C", "D"};
//This array is used to hold the limits for each setting. This is important to prevent OOB errors. Each setting limit defaults to 9 if not set
int routineSettingsLimits[numberOfRoutines][4];
int currentSetting = 0;
int currentRoutine = 0;
unsigned long lastTimeInterrupted = millis();
bool interrupted = false;
bool settingChange = false;
bool factorChange = false;
int routineFactor = 0;
int lcd_key     = 0;
int adc_key_in  = 0;


// read the buttons
int read_LCD_buttons()
{
 adc_key_in = analogRead(0);      // read the value from the sensor 
 // my buttons when read are centered at these valies: 0, 144, 329, 504, 741
 // we add approx 50 to those values and check to see if we are close
 if (adc_key_in > 1000) return btnNONE; // We make this the 1st option for speed reasons since it will be the most likely result
 // For V1.1 us this threshold
 if (adc_key_in < 50)   return btnRIGHT;  
 if (adc_key_in < 250)  return btnUP; 
 if (adc_key_in < 450)  return btnDOWN; 
 if (adc_key_in < 650)  return btnLEFT; 
 if (adc_key_in < 850)  return btnSELECT;  

 // For V1.0 comment the other threshold and use the one below:
/*
 if (adc_key_in < 50)   return btnRIGHT;  
 if (adc_key_in < 195)  return btnUP; 
 if (adc_key_in < 380)  return btnDOWN; 
 if (adc_key_in < 555)  return btnLEFT; 
 if (adc_key_in < 790)  return btnSELECT;   
*/


 return btnNONE;  // when all others fail, return this...
}

const int buttonPin = 19;     // the number of the pushbutton pin
const int ledPin =  13;      // the number of the LED pin

// variables will change:
volatile int buttonState = 0;         // variable for reading the pushbutton status


//***variables***variables***variables***variables***variables***variables***variables***variables
//These variables are used by multiplexing and Bit Angle Modulation Code
int shift_out;//used in the code a lot in for(i= type loops
byte anode[8];//byte to write to the anode shift register, 8 of them, shifting the ON level in each byte in the array

//This is how the brightness for every LED is stored,  
//Each LED only needs a 'bit' to know if it should be ON or OFF, so 64 Bytes gives you 512 bits= 512 LEDs
//Since we are modulating the LEDs, using 4 bit resolution, each color has 4 arrays containing 64 bits each
byte red0[64], red1[64], red2[64], red3[64];
byte blue0[64], blue1[64], blue2[64], blue3[64];
byte green0[64], green1[64], green2[64], green3[64];
//notice how more resolution will eat up more of your precious RAM

int level=0;//keeps track of which level we are shifting data to
int anodeLevel=0;//this increments through the anode levels
int BAM_Bit, BAM_Counter=0; // Bit Angle Modulation variables to keep track of things

//These variables can be used for other things
unsigned long start;//for a millis timer to cycle through the animations
//appealing sets of colors to use for various animations
#define numberOfColorSets 5
const int colorSets[numberOfColorSets][8][3] PROGMEM = {
  {{0, 5, 15},{0, 1, 9},{0, 0, 10},{1, 0, 11},{3, 0, 12},{10, 0, 15},{10, 0, 10},{10, 0, 1}},
  {{15, 15, 0},{10, 10, 0},{15, 5, 0},{15, 2, 0},{15, 1, 0},{15, 0, 0},{12, 0, 0},{10, 0, 0}},
  {{15, 0, 0},{15, 6, 0},{15, 15, 0},{9, 14, 0},{0, 15, 0},{0, 15, 15},{0, 0, 15},{6, 3, 15}},//rainbow
  {{6, 3, 15},{4, 3, 15},{1, 3, 15},{0, 0, 15},{1, 2, 12},{7, 1, 9},{10, 0, 7},{15, 0, 0}},//purple to blue to red
  {{0, 15, 0},{1, 12, 2},{2, 11, 7},{3, 9, 10},{4, 7, 11},{5, 5, 13},{6, 4, 14},{6, 3, 15}}//green to purple
 };
#define numberOfMessages 4
String messages[numberOfMessages] = {"??????","XXXXXX","!!!!!!!!","BASS"};
//Object transform variables
#define scrollingTextTransformSteps 14
byte scrollingTestStepsTillCleared = 8;
byte scrollingTextTransformObjects = 4;
const int scrollingTextTransform[4][scrollingTextTransformSteps][4][4] PROGMEM = 
      {
        {
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,6,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,5,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,4,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,3,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,2,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,1,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,-1,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,-2,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,-3,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,-4,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,-5,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,-6,0,1}},
          {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,-7,0,1}}
        },
        {
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,1,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,2,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,3,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,4,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,5,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,6,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,7,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,8,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,9,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,10,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,11,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,12,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,13,1}},
          {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,14,1}}
        },
        {
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,6,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,5,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,4,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,3,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,2,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,1,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,0,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,-1,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,-2,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,-3,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,-4,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,-5,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,-6,1}},
          {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,-7,1}}
        },
        {
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,1,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,2,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,3,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,4,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,5,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,6,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,7,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,8,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,9,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,10,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,11,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,12,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,13,7,1}},
          {{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,14,7,1}}
        }
      };
//rotation matrixes for rubiks animations spining CW
//0 = right 1 = left 2 = front 3 = back 4 = top 5 =bottom faces
const float rubiksRotations[6][3][4][4] PROGMEM = {
{
  {{0.923879532,0,0.382683432,0},{0,1,0,0},{-0.382683432,0,0.923879532,0},{1.605813,0,-1.07297,1}},
  {{0.707106781,0,0.707106781,0},{0,1,0,0},{-0.707106781,0,0.707106781,0},{3.5,0,0,1}},
  {{0.382683432,0,0.9238795325,0},{0,1,0,0},{-0.9238795325,0,0.382683432,0},{5.394187,0,-1.07297,1}}
},
{
  {{0.923879532,0,-0.382683432,0},{0,1,0,0},{0.382683432,0,0.923879532,0},{-1.07297,0,1.605813,1}},
  {{0.707106781,0,-0.707106781,0},{0,1,0,0},{0.707106781,0,0.707106781,0},{0,0,3.5,1}},
  {{0.382683432,0,-0.9238795325,0},{0,1,0,0},{0.9238795325,0,0.382683432,0},{-1.07297,0,5.394187,1}}
},
{
  {{0.923879532,0.382683432,0,0},{-0.382683432,0.923879532,0,0},{0,0,1,0},{1.605813,-1.07297,0,1}},
  {{0.707106781,0.707106781,0,0},{-0.707106781,0.707106781,0,0},{0,0,1,0},{3.5,-1.44975,0,1}},
  {{0.382683432,0.9238795325,0,0},{-0.9238795325,0.382683432,0,0},{0,0,1,0},{5.394187,-1.07297,0,1}}
},
{
  {{0.923879532,-0.382683432,0,0},{0.382683432,0.923879532,0,0},{0,0,1,0},{-1.07297,1.605813,0,1}},
  {{0.707106781,-0.707106781,0,0},{0.707106781,0.707106781,0,0},{0,0,1,0},{-1.44975,3.5,0,1}},
  {{0.382683432,-0.9238795325,0,0},{0.9238795325,0.382683432,0,0},{0,0,1,0},{-1.07297,5.394187,0,1}}
},
{
  {{1,0,0,0},{0,0.923879532,-0.382683432,0},{0,0.382683432,0.923879532},{0,-1.07297,1.605813,1}},
  {{1,0,0,0},{0,0.707106781,-0.707106781,0},{0,0.707106781,0.707106781},{0,-1.44975,3.5,1}},
  {{1,0,0,0},{0,0.382683432,-0.9238795325,0},{0,0.9238795325,0.382683432},{0,-1.07297,5.394187,1}}
},
{
  {{1,0,0,0},{0,0.923879532,0.382683432,0},{0,-0.382683432,0.923879532},{0,1.605813,-1.07297,1}},
  {{1,0,0,0},{0,0.707106781,0.707106781,0},{0,-0.707106781,0.707106781},{0,3.5,-1.44975,1}},
  {{1,0,0,0},{0,0.382683432,0.9238795325,0},{0,-0.9238795325,0.382683432},{0,5.394187,-1.07297,1}}
}
};
float smallCube[8][4] = {
    {3,3,3,1},
    {3,3,4,1},
    {3,4,3,1},
    {4,3,3,1},
    {4,4,4,1},
    {3,4,4,1},
    {4,3,4,1},
    {4,4,3,1}

  };
int cubeAdjacency[8][8] = {
    {0,1,1,1,0,0,0,0},
    {1,0,0,0,0,1,1,0},
    {1,0,0,0,0,1,0,1},
    {1,0,0,0,0,0,1,1},
    {0,0,0,0,0,1,1,1},
    {0,1,1,0,1,0,0,0},
    {0,1,0,1,1,0,0,0},
    {0,0,1,1,1,0,0,0}
};
#define dancingCubeTransformSteps 5
const float dancingCubeTransforms[dancingCubeTransformSteps][4][4] PROGMEM = {
 {
    {3,0,0,0},
    {0,3,0,0},
    {0,0,3,0},
    {-7,-7,-7,1},
  },
  {
    {1.7,0,0,0},
    {0,1.7,0,0},
    {0,0,1.7,0},
    {-2,-2,-2,1}
  },
  {
    {1.3,0,0,0},
    {0,1.3,0,0},
    {0,0,1.3,0},
    {-1,-1,-1,1}
  },
  {
    {0.769,0,0,0},
    {0,0.769,0,0},
    {0,0,0.769,0},
    {1,1,1,1}
  },
  {
    {0.588,0,0,0},
    {0,0.588,0,0},
    {0,0,0.588,0},
    {2,2,2,1}
  }
// {
//    {0.333,0,0,0},
//    {0,0.333,0,0},
//    {0,0,0.333,0},
//    {3,3,3,1},
//  }
  };
int identityMatrix[4][4] = {
  {1,0,0,0},
  {0,1,0,0},
  {0,0,1,0},
  {0,0,0,1}
};


const char font_data[128][8] PROGMEM = {
{ 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00 },    // 0 :
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
 
  { 0x00,  0x3E,  0x41,  0x55,  0x41,  0x55,  0x49,  0x3E },    // 1 : 
                //              |          |
                //              |   *****  |
                //              |  *     * |
                //              |  * * * * |
                //              |  *     * |
                //              |  * * * * |
                //              |  *  *  * |
                //              |   *****  |
 
  { 0x00,  0x3E,  0x7F,  0x6B,  0x7F,  0x6B,  0x77,  0x3E },    // 2 : 
                //              |          |
                //              |   *****  |
                //              |  ******* |
                //              |  ** * ** |
                //              |  ******* |
                //              |  ** * ** |
                //              |  *** *** |
                //              |   *****  |
 
  { 0x00,  0x22,  0x77,  0x7F,  0x7F,  0x3E,  0x1C,  0x08 },    // 3 : 
                //              |          |
                //              |   *   *  |
                //              |  *** *** |
                //              |  ******* |
                //              |  ******* |
                //              |   *****  |
                //              |    ***   |
                //              |     *    |
 
  { 0x00,  0x08,  0x1C,  0x3E,  0x7F,  0x3E,  0x1C,  0x08 },    // 4 : 
                //              |          |
                //              |     *    |
                //              |    ***   |
                //              |   *****  |
                //              |  ******* |
                //              |   *****  |
                //              |    ***   |
                //              |     *    |
 
  { 0x00,  0x08,  0x1C,  0x2A,  0x7F,  0x2A,  0x08,  0x1C },    // 5 : 
                //              |          |
                //              |     *    |
                //              |    ***   |
                //              |   * * *  |
                //              |  ******* |
                //              |   * * *  |
                //              |     *    |
                //              |    ***   |
 
  { 0x00,  0x08,  0x1C,  0x3E,  0x7F,  0x3E,  0x08,  0x1C },    // 6 : 
                //              |          |
                //              |     *    |
                //              |    ***   |
                //              |   *****  |
                //              |  ******* |
                //              |   *****  |
                //              |     *    |
                //              |    ***   |
 
  { 0x00,  0x00,  0x1C,  0x3E,  0x3E,  0x3E,  0x1C,  0x00 },    // 7 : 
                //              |          |
                //              |          |
                //              |    ***   |
                //              |   *****  |
                //              |   *****  |
                //              |   *****  |
                //              |    ***   |
                //              |          |
 
  { 0xFF,  0xFF,  0xE3,  0xC1,  0xC1,  0xC1,  0xE3,  0xFF },    // 8 : 
                //              | ******** |
                //              | ******** |
                //              | ***   ** |
                //              | **     * |
                //              | **     * |
                //              | **     * |
                //              | ***   ** |
                //              | ******** |
 
  { 0x00,  0x00,  0x1C,  0x22,  0x22,  0x22,  0x1C,  0x00 },    // 9 :  
                //              |          |
                //              |          |
                //              |    ***   |
                //              |   *   *  |
                //              |   *   *  |
                //              |   *   *  |
                //              |    ***   |
                //              |          |
 
  { 0xFF,  0xFF,  0xE3,  0xDD,  0xDD,  0xDD,  0xE3,  0xFF },    // 10 :
 
                //              | ******** |
                //              | ******** |
                //              | ***   ** |
                //              | ** *** * |
                //              | ** *** * |
                //              | ** *** * |
                //              | ***   ** |
                //              | ******** |
 
  { 0x00,  0x0F,  0x03,  0x05,  0x39,  0x48,  0x48,  0x30 },    // 11 : 
                //              |          |
                //              |     **** |
                //              |       ** |
                //              |      * * |
                //              |   ***  * |
                //              |  *  *    |
                //              |  *  *    |
                //              |   **     |
 
  { 0x00,  0x08,  0x3E,  0x08,  0x1C,  0x22,  0x22,  0x1C },    // 12 : 
                //              |          |
                //              |     *    |
                //              |   *****  |
                //              |     *    |
                //              |    ***   |
                //              |   *   *  |
                //              |   *   *  |
                //              |    ***   |
 
  { 0x00,  0x18,  0x14,  0x10,  0x10,  0x30,  0x70,  0x60 },    // 13 :
 
                //              |          |
                //              |    **    |
                //              |    * *   |
                //              |    *     |
                //              |    *     |
                //              |   **     |
                //              |  ***     |
                //              |  **      |
 
  { 0x00,  0x0F,  0x19,  0x11,  0x13,  0x37,  0x76,  0x60 },    // 14 : 
                //              |          |
                //              |     **** |
                //              |    **  * |
                //              |    *   * |
                //              |    *  ** |
                //              |   ** *** |
                //              |  *** **  |
                //              |  **      |
 
  { 0x00,  0x08,  0x2A,  0x1C,  0x77,  0x1C,  0x2A,  0x08 },    // 15 : 
                //              |          |
                //              |     *    |
                //              |   * * *  |
                //              |    ***   |
                //              |  *** *** |
                //              |    ***   |
                //              |   * * *  |
                //              |     *    |
 
  { 0x00,  0x60,  0x78,  0x7E,  0x7F,  0x7E,  0x78,  0x60 },    // 16 : 
                //              |          |
                //              |  **      |
                //              |  ****    |
                //              |  ******  |
                //              |  ******* |
                //              |  ******  |
                //              |  ****    |
                //              |  **      |
 
  { 0x00,  0x03,  0x0F,  0x3F,  0x7F,  0x3F,  0x0F,  0x03 },    // 17 : 
                //              |          |
                //              |       ** |
                //              |     **** |
                //              |   ****** |
                //              |  ******* |
                //              |   ****** |
                //              |     **** |
                //              |       ** |
 
  { 0x00,  0x08,  0x1C,  0x2A,  0x08,  0x2A,  0x1C,  0x08 },    // 18 : 
                //              |          |
                //              |     *    |
                //              |    ***   |
                //              |   * * *  |
                //              |     *    |
                //              |   * * *  |
                //              |    ***   |
                //              |     *    |
 
  { 0x00,  0x66,  0x66,  0x66,  0x66,  0x00,  0x66,  0x66 },    // 19 : 
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
 
  { 0x00,  0x3F,  0x65,  0x65,  0x3D,  0x05,  0x05,  0x05 },    // 20 : 
                //              |          |
                //              |   ****** |
                //              |  **  * * |
                //              |  **  * * |
                //              |   **** * |
                //              |      * * |
                //              |      * * |
                //              |      * * |
 
  { 0x00,  0x0C,  0x32,  0x48,  0x24,  0x12,  0x4C,  0x30 },    // 21 : 
                //              |          |
                //              |     **   |
                //              |   **  *  |
                //              |  *  *    |
                //              |   *  *   |
                //              |    *  *  |
                //              |  *  **   |
                //              |   **     |
 
  { 0x00,  0x00,  0x00,  0x00,  0x00,  0x7F,  0x7F,  0x7F },    // 22 : 
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |  ******* |
                //              |  ******* |
                //              |  ******* |
 
  { 0x00,  0x08,  0x1C,  0x2A,  0x08,  0x2A,  0x1C,  0x3E },    // 23 : 
                //              |          |
                //              |     *    |
                //              |    ***   |
                //              |   * * *  |
                //              |     *    |
                //              |   * * *  |
                //              |    ***   |
                //              |   *****  |
 
  { 0x08,  0x1C,  0x3E,  0x7F,  0x1C,  0x1C,  0x1C ,0x00},    // 24 : 
                //              |     *    |
                //              |    ***   |
                //              |   *****  |
                //              |  ******* |
                //              |    ***   |
                //              |    ***   |
                //              |    ***   |
                //              |          |
 
  { 0x1C,  0x1C,  0x1C,  0x7F,  0x3E,  0x1C,  0x08,0x00 },    // 25 : 
                //              |    ***   |
                //              |    ***   |
                //              |    ***   |
                //              |  ******* |
                //              |   *****  |
                //              |    ***   |
                //              |     *    |
                //              |          |
 
  {0x08,  0x0C,  0x7E,  0x7F,  0x7E,  0x0C,  0x08 ,0x00},    // 26 : 
                //              |     *    |
                //              |     **   |
                //              |  ******  |
                //              |  ******* |
                //              |  ******  |
                //              |     **   |
                //              |     *    |
                //              |          |
 
  {0x08,  0x18,  0x3F,  0x7F,  0x3F,  0x18,  0x08 ,0x00},    // 27 : 
                //              |     *    |
                //              |    **    |
                //              |   ****** |
                //              |  ******* |
                //              |   ****** |
                //              |    **    |
                //              |     *    |
                //              |          |
 
  { 0x00,  0x00,  0x00,  0x70,  0x70,  0x70,  0x7F,  0x7F },    // 28 : 
                //              |          |
                //              |          |
                //              |          |
                //              |  ***     |
                //              |  ***     |
                //              |  ***     |
                //              |  ******* |
                //              |  ******* |
 
  { 0x00,  0x00,  0x14,  0x22,  0x7F,  0x22,  0x14,  0x00 },    // 29 : 
                //              |          |
                //              |          |
                //              |    * *   |
                //              |   *   *  |
                //              |  ******* |
                //              |   *   *  |
                //              |    * *   |
                //              |          |
 
  { 0x00,  0x08,  0x1C,  0x1C,  0x3E,  0x3E,  0x7F,  0x7F },    // 30 : 
                //              |          |
                //              |     *    |
                //              |    ***   |
                //              |    ***   |
                //              |   *****  |
                //              |   *****  |
                //              |  ******* |
                //              |  ******* |
 
  { 0x00,  0x7F,  0x7F,  0x3E,  0x3E,  0x1C,  0x1C,  0x08 },    // 31 : 
                //              |          |
                //              |  ******* |
                //              |  ******* |
                //              |   *****  |
                //              |   *****  |
                //              |    ***   |
                //              |    ***   |
                //              |     *    |
 
  { 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00 },    // 32 :  
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
 
  {  0x18,  0x18,  0x18,  0x18,  0x18,  0x00,  0x18, 0x18 },    // 33 : !
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |          |
                //              |    **    |
                //              |    **    |
 
  { 0x00,  0x36,  0x36,  0x14,  0x00,  0x00,  0x00,  0x00 },    // 34 : "
                //              |          |
                //              |   ** **  |
                //              |   ** **  |
                //              |    * *   |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
 
  { 0x00,  0x36,  0x36,  0x7F,  0x36,  0x7F,  0x36,  0x36 },    // 35 : #
                //              |          |
                //              |   ** **  |
                //              |   ** **  |
                //              |  ******* |
                //              |   ** **  |
                //              |  ******* |
                //              |   ** **  |
                //              |   ** **  |
 
  { 0x00,  0x08,  0x1E,  0x20,  0x1C,  0x02,  0x3C,  0x08 },    // 36 : $
                //              |          |
                //              |     *    |
                //              |    ****  |
                //              |   *      |
                //              |    ***   |
                //              |       *  |
                //              |   ****   |
                //              |     *    |
 
  { 0x00,  0x60,  0x66,  0x0C,  0x18,  0x30,  0x66,  0x06 },    // 37 : %
                //              |          |
                //              |  **      |
                //              |  **  **  |
                //              |     **   |
                //              |    **    |
                //              |   **     |
                //              |  **  **  |
                //              |      **  |
 
  { 0x00,  0x3C,  0x66,  0x3C,  0x28,  0x65,  0x66,  0x3F },    // 38 : &
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |   ****   |
                //              |   * *    |
                //              |  **  * * |
                //              |  **  **  |
                //              |   ****** |
 
  { 0x00,  0x18,  0x18,  0x18,  0x30,  0x00,  0x00,  0x00 },    // 39 : '
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |   **     |
                //              |          |
                //              |          |
                //              |          |
 
  { 0x00,  0x60,  0x30,  0x18,  0x18,  0x18,  0x30,  0x60 },    // 40 : (
                //              |          |
                //              |  **      |
                //              |   **     |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |   **     |
                //              |  **      |
 
  { 0x00,  0x06,  0x0C,  0x18,  0x18,  0x18,  0x0C,  0x06 },    // 41 : )
                //              |          |
                //              |      **  |
                //              |     **   |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |     **   |
                //              |      **  |
 
  { 0x00,  0x00,  0x36,  0x1C,  0x7F,  0x1C,  0x36,  0x00 },    // 42 : *
                //              |          |
                //              |          |
                //              |   ** **  |
                //              |    ***   |
                //              |  ******* |
                //              |    ***   |
                //              |   ** **  |
                //              |          |
 
  { 0x00,  0x00,  0x08,  0x08,  0x3E,  0x08,  0x08,  0x00 },    // 43 : +
                //              |          |
                //              |          |
                //              |     *    |
                //              |     *    |
                //              |   *****  |
                //              |     *    |
                //              |     *    |
                //              |          |
 
  { 0x00,  0x00,  0x00,  0x00,  0x30,  0x30,  0x30,  0x60 },    // 44 : ,
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |   **     |
                //              |   **     |
                //              |   **     |
                //              |  **      |
 
  { 0x00,  0x00,  0x00,  0x00,  0x3C,  0x00,  0x00,  0x00 },    // 45 : -
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |   ****   |
                //              |          |
                //              |          |
                //              |          |
 
  { 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x60,  0x60 },    // 46 : .
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |  **      |
                //              |  **      |
 
  { 0x00,  0x00,  0x06,  0x0C,  0x18,  0x30,  0x60,  0x00 },    // 47 : /
                //              |          |
                //              |          |
                //              |      **  |
                //              |     **   |
                //              |    **    |
                //              |   **     |
                //              |  **      |
                //              |          |
 
  { 0x3C,  0x66,  0x6E,  0x76,  0x66,  0x66,  0x3C,0x00},    // 48 : 0

                //              |   ****   |
                //              |  **  **  |
                //              |  ** ***  |
                //              |  *** **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
 
  {0x18,  0x18,  0x38,  0x18,  0x18,  0x18,  0x7E,0x00 },    // 49 : 1

                //              |    **    |
                //              |    **    |
                //              |   ***    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |  ******  |
 
  {0x3C,  0x66,  0x06,  0x0C,  0x30,  0x60,  0x7E ,0x00},    // 50 : 2
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |      **  |
                //              |     **   |
                //              |   **     |
                //              |  **      |
                //              |  ******  |
 
  {0x3C,  0x66,  0x06,  0x1C,  0x06,  0x66,  0x3C ,0x00},    // 51 : 3
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |      **  |
                //              |    ***   |
                //              |      **  |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x0C,  0x1C,  0x2C,  0x4C,  0x7E,  0x0C,  0x0C ,0x00},    // 52 : 4
                //              |          |
                //              |     **   |
                //              |    ***   |
                //              |   * **   |
                //              |  *  **   |
                //              |  ******  |
                //              |     **   |
                //              |     **   |
 
  {   0x7E,  0x60,  0x7C,  0x06,  0x06,  0x66,  0x3C ,0x00},    // 53 : 5
                //              |          |
                //              |  ******  |
                //              |  **      |
                //              |  *****   |
                //              |      **  |
                //              |      **  |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x3C,  0x66,  0x60,  0x7C,  0x66,  0x66,  0x3C ,0x00},    // 54 : 6
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **      |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x7E,  0x66,  0x0C,  0x0C,  0x18,  0x18,  0x18,0x00 },    // 55 : 7
                //              |          |
                //              |  ******  |
                //              |  **  **  |
                //              |     **   |
                //              |     **   |
                //              |    **    |
                //              |    **    |
                //              |    **    |
 
  {   0x3C,  0x66,  0x66,  0x3C,  0x66,  0x66,  0x3C ,0x00},    // 56 : 8
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x3C,  0x66,  0x66,  0x3E,  0x06,  0x66,  0x3C ,0x00},    // 57 : 9
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |   *****  |
                //              |      **  |
                //              |  **  **  |
                //              |   ****   |
 
  {0x00,  0x18,  0x18,  0x00,  0x18,  0x18,  0x00,0x00 },    // 58 : :
                //              |          |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |          |
 
  { 0x00,  0x00,  0x18,  0x18,  0x00,  0x18,  0x18,  0x30 },    // 59 : ;
                //              |          |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |   **     |
 
  { 0x00,  0x06,  0x0C,  0x18,  0x30,  0x18,  0x0C,  0x06 },    // 60 : <
                //              |          |
                //              |      **  |
                //              |     **   |
                //              |    **    |
                //              |   **     |
                //              |    **    |
                //              |     **   |
                //              |      **  |
 
  { 0x00,  0x00,  0x00,  0x3C,  0x00,  0x3C,  0x00,  0x00 },    // 61 : =
                //              |          |
                //              |          |
                //              |          |
                //              |   ****   |
                //              |          |
                //              |   ****   |
                //              |          |
                //              |          |
 
  { 0x00,  0x60,  0x30,  0x18,  0x0C,  0x18,  0x30,  0x60 },    // 62 : >
                //              |          |
                //              |  **      |
                //              |   **     |
                //              |    **    |
                //              |     **   |
                //              |    **    |
                //              |   **     |
                //              |  **      |
 
  {0x3C,  0x66,  0x06,  0x1C,  0x18,  0x00,  0x18,0x18 },    // 63 : ?
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |      **  |
                //              |    ***   |
                //              |    **    |
                //              |          |
                //              |    **    |
 
  { 0x00,  0x38,  0x44,  0x5C,  0x58,  0x42,  0x3C,  0x00 },    // 64 : @
                //              |          |
                //              |   ***    |
                //              |  *   *   |
                //              |  * ***   |
                //              |  * **    |
                //              |  *    *  |
                //              |   ****   |
                //              |          |
 
  {  0x3C,  0x66,  0x66,  0x7E,  0x66,  0x66,  0x66 , 0x00},    // 65 : A
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  ******  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
 
  {   0x7C,  0x66,  0x66,  0x7C,  0x66,  0x66,  0x7C , 0x00},    // 66 : B
                //              |          |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  *****   |
 
  {   0x3C,  0x66,  0x60,  0x60,  0x60,  0x66,  0x3C , 0x00},    // 67 : C
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **      |
                //              |  **      |
                //              |  **      |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x7C,  0x66,  0x66,  0x66,  0x66,  0x66,  0x7C , 0x00},    // 68 : D
                //              |          |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  *****   |
 
  {   0x7E,  0x60,  0x60,  0x7C,  0x60,  0x60,  0x7E , 0x00},    // 69 : E
                //              |          |
                //              |  ******  |
                //              |  **      |
                //              |  **      |
                //              |  *****   |
                //              |  **      |
                //              |  **      |
                //              |  ******  |
 
  {   0x7E,  0x60,  0x60,  0x7C,  0x60,  0x60,  0x60 },    // 70 : F
                //              |          |
                //              |  ******  |
                //              |  **      |
                //              |  **      |
                //              |  *****   |
                //              |  **      |
                //              |  **      |
                //              |  **      |
 
  {   0x3C,  0x66,  0x60,  0x60,  0x6E,  0x66,  0x3C },    // 71 : G
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **      |
                //              |  **      |
                //              |  ** ***  |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x66,  0x66,  0x66,  0x7E,  0x66,  0x66,  0x66 },    // 72 : H
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  ******  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
 
  {   0x3C,  0x18,  0x18,  0x18,  0x18,  0x18,  0x3C },    // 73 : I
                //              |          |
                //              |   ****   |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |   ****   |
 
  {   0x1E,  0x0C,  0x0C,  0x0C,  0x6C,  0x6C,  0x38 },    // 74 : J
                //              |          |
                //              |    ****  |
                //              |     **   |
                //              |     **   |
                //              |     **   |
                //              |  ** **   |
                //              |  ** **   |
                //              |   ***    |
 
  {   0x66,  0x6C,  0x78,  0x70,  0x78,  0x6C,  0x66 },    // 75 : K
                //              |          |
                //              |  **  **  |
                //              |  ** **   |
                //              |  ****    |
                //              |  ***     |
                //              |  ****    |
                //              |  ** **   |
                //              |  **  **  |
 
  {   0x60,  0x60,  0x60,  0x60,  0x60,  0x60,  0x7E , 0x00},    // 76 : L
                //              |  **      |
                //              |  **      |
                //              |  **      |
                //              |  **      |
                //              |  **      |
                //              |  **      |
                //              |  ******  |
                //              |          |
 
  {   0x63,  0x77,  0x7F,  0x6B,  0x63,  0x63,  0x63 , 0x00},    // 77 : M
                //              |          |
                //              |  **   ** |
                //              |  *** *** |
                //              |  ******* |
                //              |  ** * ** |
                //              |  **   ** |
                //              |  **   ** |
                //              |  **   ** |
 
  {   0x63,  0x73,  0x7B,  0x6F,  0x67,  0x63,  0x63 , 0x00},    // 78 : N
                //              |          |
                //              |  **   ** |
                //              |  ***  ** |
                //              |  **** ** |
                //              |  ** **** |
                //              |  **  *** |
                //              |  **   ** |
                //              |  **   ** |
 
  {   0x3C,  0x66,  0x66,  0x66,  0x66,  0x66,  0x3C , 0x00},    // 79 : O
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x7C,  0x66,  0x66,  0x66,  0x7C,  0x60,  0x60 , 0x00},    // 80 : P
                //              |          |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  *****   |
                //              |  **      |
                //              |  **      |
 
  {   0x3C,  0x66,  0x66,  0x66,  0x6E,  0x3C,  0x06 , 0x00},    // 81 : Q
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  ** ***  |
                //              |   ****   |
                //              |      **  |
 
  {   0x7C,  0x66,  0x66,  0x7C,  0x78,  0x6C,  0x66 , 0x00},    // 82 : R
                //              |          |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  *****   |
                //              |  ****    |
                //              |  ** **   |
                //              |  **  **  |
 
  {   0x3C,  0x66,  0x60,  0x3C,  0x06,  0x66,  0x3C , 0x00},    // 83 : S
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **      |
                //              |   ****   |
                //              |      **  |
                //              |  **  **  |
                //              |   ****   |
 
  {   0x7E,  0x5A,  0x18,  0x18,  0x18,  0x18,  0x18 , 0x00},    // 84 : T
                //              |          |
                //              |  ******  |
                //              |  * ** *  |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
 
  {   0x66,  0x66,  0x66,  0x66,  0x66,  0x66,  0x3E , 0x00},    // 85 : U
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   *****  |
 
  {   0x66,  0x66,  0x66,  0x66,  0x66,  0x3C,  0x18 , 0x00},    // 86 : V
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
                //              |    **    |
 
  {   0x63,  0x63,  0x63,  0x6B,  0x7F,  0x77,  0x63 , 0x00},    // 87 : W
                //              |          |
                //              |  **   ** |
                //              |  **   ** |
                //              |  **   ** |
                //              |  ** * ** |
                //              |  ******* |
                //              |  *** *** |
                //              |  **   ** |
 
  {   0x63,  0x63,  0x36,  0x1C,  0x36,  0x63,  0x63 , 0x00},    // 88 : X
                //              |          |
                //              |  **   ** |
                //              |  **   ** |
                //              |   ** **  |
                //              |    ***   |
                //              |   ** **  |
                //              |  **   ** |
                //              |  **   ** |
 
  {   0x66,  0x66,  0x66,  0x3C,  0x18,  0x18,  0x18 , 0x00},    // 89 : Y
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
                //              |    **    |
                //              |    **    |
                //              |    **    |
 
  {   0x7E,  0x06,  0x0C,  0x18,  0x30,  0x60,  0x7E , 0x00},    // 90 : Z
                //              |          |
                //              |  ******  |
                //              |      **  |
                //              |     **   |
                //              |    **    |
                //              |   **     |
                //              |  **      |
                //              |  ******  |
 
  { 0x00,  0x1E,  0x18,  0x18,  0x18,  0x18,  0x18,  0x1E },    // 91 : [
                //              |          |
                //              |    ****  |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    ****  |
 
  { 0x00,  0x00,  0x60,  0x30,  0x18,  0x0C,  0x06,  0x00 },    // 92 : \
                //              |          |
                //              |          |
                //              |  **      |
                //              |   **     |
                //              |    **    |
                //              |     **   |
                //              |      **  |
                //              |          |
 
  { 0x00,  0x78,  0x18,  0x18,  0x18,  0x18,  0x18,  0x78 },    // 93 : ]
                //              |          |
                //              |  ****    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |  ****    |
 
  { 0x00,  0x08,  0x14,  0x22,  0x41,  0x00,  0x00,  0x00 },    // 94 : ^
                //              |          |
                //              |     *    |
                //              |    * *   |
                //              |   *   *  |
                //              |  *     * |
                //              |          |
                //              |          |
                //              |          |
 
  { 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x7F },    // 95 : _
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |  ******* |
 
  { 0x00,  0x0C,  0x0C,  0x06,  0x00,  0x00,  0x00,  0x00 },    // 96 : `
                //              |          |
                //              |     **   |
                //              |     **   |
                //              |      **  |
                //              |          |
                //              |          |
                //              |          |
                //              |          |
 
  { 0x00,  0x00,  0x00,  0x3C,  0x06,  0x3E,  0x66,  0x3E },    // 97 : a
                //              |          |
                //              |          |
                //              |          |
                //              |   ****   |
                //              |      **  |
                //              |   *****  |
                //              |  **  **  |
                //              |   *****  |
 
  { 0x00,  0x60,  0x60,  0x60,  0x7C,  0x66,  0x66,  0x7C },    // 98 : b
                //              |          |
                //              |  **      |
                //              |  **      |
                //              |  **      |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  *****   |
 
  { 0x00,  0x00,  0x00,  0x3C,  0x66,  0x60,  0x66,  0x3C },    // 99 : c
                //              |          |
                //              |          |
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **      |
                //              |  **  **  |
                //              |   ****   |
 
  { 0x00,  0x06,  0x06,  0x06,  0x3E,  0x66,  0x66,  0x3E },    // 100 : d
                //              |          |
                //              |      **  |
                //              |      **  |
                //              |      **  |
                //              |   *****  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   *****  |
 
  { 0x00,  0x00,  0x00,  0x3C,  0x66,  0x7E,  0x60,  0x3C },    // 101 : e
                //              |          |
                //              |          |
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  ******  |
                //              |  **      |
                //              |   ****   |
 
  { 0x00,  0x1C,  0x36,  0x30,  0x30,  0x7C,  0x30,  0x30 },    // 102 : f
                //              |          |
                //              |    ***   |
                //              |   ** **  |
                //              |   **     |
                //              |   **     |
                //              |  *****   |
                //              |   **     |
                //              |   **     |
 
  { 0x00,  0x00,  0x3E,  0x66,  0x66,  0x3E,  0x06,  0x3C },    // 103 : g
                //              |          |
                //              |          |
                //              |   *****  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   *****  |
                //              |      **  |
                //              |   ****   |
 
  { 0x00,  0x60,  0x60,  0x60,  0x7C,  0x66,  0x66,  0x66 },    // 104 : h
                //              |          |
                //              |  **      |
                //              |  **      |
                //              |  **      |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
 
  { 0x00,  0x00,  0x18,  0x00,  0x18,  0x18,  0x18,  0x3C },    // 105 : i
                //              |          |
                //              |          |
                //              |    **    |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |   ****   |
 
  { 0x00,  0x0C,  0x00,  0x0C,  0x0C,  0x6C,  0x6C,  0x38 },    // 106 : j
                //              |          |
                //              |     **   |
                //              |          |
                //              |     **   |
                //              |     **   |
                //              |  ** **   |
                //              |  ** **   |
                //              |   ***    |
 
  { 0x00,  0x60,  0x60,  0x66,  0x6C,  0x78,  0x6C,  0x66 },    // 107 : k
                //              |          |
                //              |  **      |
                //              |  **      |
                //              |  **  **  |
                //              |  ** **   |
                //              |  ****    |
                //              |  ** **   |
                //              |  **  **  |
 
  { 0x00,  0x18,  0x18,  0x18,  0x18,  0x18,  0x18,  0x18 },    // 108 : l
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |    **    |
 
  { 0x00,  0x00,  0x00,  0x63,  0x77,  0x7F,  0x6B,  0x6B },    // 109 : m
                //              |          |
                //              |          |
                //              |          |
                //              |  **   ** |
                //              |  *** *** |
                //              |  ******* |
                //              |  ** * ** |
                //              |  ** * ** |
 
  { 0x00,  0x00,  0x00,  0x7C,  0x7E,  0x66,  0x66,  0x66 },    // 110 : n
                //              |          |
                //              |          |
                //              |          |
                //              |  *****   |
                //              |  ******  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
 
  { 0x00,  0x00,  0x00,  0x3C,  0x66,  0x66,  0x66,  0x3C },    // 111 : o
                //              |          |
                //              |          |
                //              |          |
                //              |   ****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
 
  { 0x00,  0x00,  0x7C,  0x66,  0x66,  0x7C,  0x60,  0x60 },    // 112 : p
                //              |          |
                //              |          |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  *****   |
                //              |  **      |
                //              |  **      |
 
  { 0x00,  0x00,  0x3C,  0x6C,  0x6C,  0x3C,  0x0D,  0x0F },    // 113 : q
                //              |          |
                //              |          |
                //              |   ****   |
                //              |  ** **   |
                //              |  ** **   |
                //              |   ****   |
                //              |     ** * |
                //              |     **** |
 
  { 0x00,  0x00,  0x00,  0x7C,  0x66,  0x66,  0x60,  0x60 },    // 114 : r
                //              |          |
                //              |          |
                //              |          |
                //              |  *****   |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **      |
                //              |  **      |
 
  { 0x00,  0x00,  0x00,  0x3E,  0x40,  0x3C,  0x02,  0x7C },    // 115 : s
                //              |          |
                //              |          |
                //              |          |
                //              |   *****  |
                //              |  *       |
                //              |   ****   |
                //              |       *  |
                //              |  *****   |
 
  { 0x00,  0x00,  0x18,  0x18,  0x7E,  0x18,  0x18,  0x18 },    // 116 : t
                //              |          |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |  ******  |
                //              |    **    |
                //              |    **    |
                //              |    **    |
 
  { 0x00,  0x00,  0x00,  0x66,  0x66,  0x66,  0x66,  0x3E },    // 117 : u
                //              |          |
                //              |          |
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |  **  **  |
                //              |   *****  |
 
  { 0x00,  0x00,  0x00,  0x00,  0x66,  0x66,  0x3C,  0x18 },    // 118 : v
                //              |          |
                //              |          |
                //              |          |
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |   ****   |
                //              |    **    |
 
  { 0x00,  0x00,  0x00,  0x63,  0x6B,  0x6B,  0x6B,  0x3E },    // 119 : w
                //              |          |
                //              |          |
                //              |          |
                //              |  **   ** |
                //              |  ** * ** |
                //              |  ** * ** |
                //              |  ** * ** |
                //              |   *****  |
 
  { 0x00,  0x00,  0x00,  0x66,  0x3C,  0x18,  0x3C,  0x66 },    // 120 : x
                //              |          |
                //              |          |
                //              |          |
                //              |  **  **  |
                //              |   ****   |
                //              |    **    |
                //              |   ****   |
                //              |  **  **  |
 
  { 0x00,  0x00,  0x00,  0x66,  0x66,  0x3E,  0x06,  0x3C },    // 121 : y
                //              |          |
                //              |          |
                //              |          |
                //              |  **  **  |
                //              |  **  **  |
                //              |   *****  |
                //              |      **  |
                //              |   ****   |
 
  { 0x00,  0x00,  0x00,  0x3C,  0x0C,  0x18,  0x30,  0x3C },    // 122 : z
                //              |          |
                //              |          |
                //              |          |
                //              |   ****   |
                //              |     **   |
                //              |    **    |
                //              |   **     |
                //              |   ****   |
 
  { 0x00,  0x0E,  0x18,  0x18,  0x30,  0x18,  0x18,  0x0E },    // 123 : {
                //              |          |
                //              |     ***  |
                //              |    **    |
                //              |    **    |
                //              |   **     |
                //              |    **    |
                //              |    **    |
                //              |     ***  |
 
  { 0x00,  0x18,  0x18,  0x18,  0x00,  0x18,  0x18,  0x18 },    // 124 : |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |    **    |
                //              |          |
                //              |    **    |
                //              |    **    |
                //              |    **    |
 
  { 0x00,  0x70,  0x18,  0x18,  0x0C,  0x18,  0x18,  0x70 },    // 125 : }
                //              |          |
                //              |  ***     |
                //              |    **    |
                //              |    **    |
                //              |     **   |
                //              |    **    |
                //              |    **    |
                //              |  ***     |
 
  { 0x00,  0x00,  0x00,  0x3A,  0x6C,  0x00,  0x00,  0x00 },    // 126 : ~
                //              |          |
                //              |          |
                //              |          |
                //              |   *** *  |
                //              |  ** **   |
                //              |          |
                //              |          |
                //              |          |
 
  { 0x00,  0x08,  0x1C,  0x36,  0x63,  0x41,  0x41,  0x7F }    // 127 : 
                //              |          |
                //              |     *    |
                //              |    ***   |
                //              |   ** **  |
                //              |  **   ** |
                //              |  *     * |
                //              |  *     * |
                //              |  ******* |
 
 
};




//****setup****setup****setup****setup****setup****setup****setup****setup****setup****setup****setup****setup****setup
void setup(){
//The second setting, "B" defaults to 6
for (int i = 0; i < numberOfRoutines; i++) {
  routineSettings[i][1] = 6;
  routineSettings[i][0] = 3;
  for (int j = 0; j < 4; j++) {
    if (routineSettingsLimits[i][j] == 0) {
      routineSettingsLimits[i][j] = 9;
    }
  }
}
  // initialize the pushbutton pin as an input:
pinMode(buttonPin, INPUT);
// Attach an interrupt to the ISR vector
attachInterrupt(digitalPinToInterrupt(buttonPin), pin_ISR, FALLING);
Serial.begin(9600); 
SPI.setBitOrder(MSBFIRST);//Most Significant Bit First
SPI.setDataMode(SPI_MODE0);// Mode 0 Rising edge of data, keep clock low
// SPI.setClockDivider(SPI_CLOCK_DIV2);//Run the data in at 16MHz/2 - 8MHz
SPI.setClockDivider(SPI_CLOCK_DIV2);//Run the data in at 16MHz/2 - 8MHz

//Serial.begin(115200);// if you need it?
noInterrupts();// kill interrupts until everybody is set up

//We use Timer 1 to refresh the cube
TCCR1A = B00000000;//Register A all 0's since we're not toggling any pins
TCCR1B = B00001011;//bit 3 set to place in CTC mode, will call an interrupt on a counter match
//bits 0 and 1 are set to divide the clock by 64, so 16MHz/64=250kHz
TIMSK1 = B00000010;//bit 1 set to call the interrupt on an OCR1A match
OCR1A=45; // you can play with this, but I set it to 30, which means:
//our clock runs at 250kHz, which is 1/250kHz = 4us
//with OCR1A set to 30, this means the interrupt will be called every (30+1)x4us=124us, 
// which gives a multiplex frequency of about 8kHz

// here I just set up the anode array, this is what's written to the anode shift register, to enable each level
anode[0]=B11111110;
anode[7]=B11111101;
anode[6]=B11111011;
anode[5]=B11110111;
anode[4]=B11101111;
anode[3]=B11011111;
anode[2]=B10111111;
anode[1]=B01111111;
// don't hate on how I assigned the values to this register! haha


//finally set up the Outputs
// pinMode(latch_pin, OUTPUT);//Latch
pinMode (2, OUTPUT); // turn off PWM and set PortD bit 4 as output
pinMode (3, OUTPUT); // turn off PWM and set PortD bit 5 as output
pinMode(data_pin, OUTPUT);//MOSI DATA
pinMode(clock_pin, OUTPUT);//SPI Clock
//pinMode(blank_pin, OUTPUT);//Output Enable  important to do this last, so LEDs do not flash on boot up

//*** Here layer pins are set as outputs
pinMode(layer1, OUTPUT);
pinMode(layer2, OUTPUT);
pinMode(layer3, OUTPUT);
pinMode(layer4, OUTPUT);
pinMode(layer5, OUTPUT);
pinMode(layer6, OUTPUT);
pinMode(layer7, OUTPUT);
pinMode(layer8, OUTPUT);



SPI.begin();//start up the SPI library
interrupts();//let the show begin, this lets the multiplexing start
randomSeed(analogRead(1));
}//***end setup***end setup***end setup***end setup***end setup***end setup***end setup***end setup***end setup***end setup


void loop(){//***start loop***start loop***start loop***start loop***start loop***start loop***start loop***start loop***start loop
//Serial.print("START LOOP currentRoutine ");Serial.println(currentRoutine);
//Each animation located in a sub routine
// To control an LED, you simply:
// LED(level you want 0-7, row you want 0-7, column you want 0-7, red brighness 0-15, green brighness 0-15, blue brighness 0-15);
  if (currentRoutine < 0) {
    currentRoutine = numberOfRoutines-1;
   } else if (currentRoutine > numberOfRoutines) {
    currentRoutine = 0;
   }
    switch (currentRoutine) {
      case 0 : 
      {
        //leave blank because of some weird bug making cube never loop back to case 0
        break;
      }
      case 1 : 
      {
        rubiksCube(routineSettings[currentRoutine]);
        break;
      }
      case 2 : 
      {
        //rubiksCube(routineSettings[currentRoutine]);
        displayTextRoutine(routineSettings[currentRoutine]);
        break;
      }
      case 3 : 
      {
        rainVersionTwo(routineSettings[currentRoutine]);
        clean(); 
        break;
      }
      case 4 : 
      {
        folder(routineSettings[currentRoutine]);
        clean();
        break;
      }
      case 5 : 
      {
        wipe_out();
        clean();
        break;
      }
      case 6 : 
      {
        glowingCube(routineSettings[currentRoutine]);
        break;
      }
      case 7 : 
      {
        color_wheelTWO();
        clean();
        break;
      }
      case 8 : 
      {
        harlem_shake();
        clean();
        break;
      }
      case 9 :
      {
        bouncyvTwo();
        clean();
        break;
      }
      case 10 :
      {
        fireworks(40,15,0,routineSettings[currentRoutine]);
        break;
      }
      case 11 : 
      {
        dancingCube(routineSettings[currentRoutine]);
        break;
      }
      case 12 :
      {
        hyperCube(routineSettings[currentRoutine]);
        clean();
      }
      case 13 :
      {
        sinwaveTwo();
        clean();
      }
      default : 
      {
        currentRoutine = 0;
        break;
      }
    }
currentRoutine++;


}//***end loop***end loop***end loop***end loop***end loop***end loop***end loop***end loop***end loop***end loop***end loop***end loop





void pin_ISR() {
 if (millis() - lastTimeInterrupted < 400)
  return;
 lastTimeInterrupted = millis();
 lcd_key = read_LCD_buttons();  // read the buttons
 interrupted = true;
 switch (lcd_key)               // depending on which button was pushed, we perform an action
 {
   case btnRIGHT:
     {
      //currentRoutine++;
     Serial.print("currentRoutine ");Serial.println(currentRoutine);
     break;
     }
   case btnLEFT:
     {
     currentRoutine-=2;
     Serial.print("currentRoutine ");Serial.println(currentRoutine);
     break;
     }
   case btnUP:
     {
     if (++routineSettings[currentRoutine][currentSetting] > routineSettingsLimits[currentRoutine][currentSetting])
      routineSettings[currentRoutine][currentSetting] = routineSettingsLimits[currentRoutine][currentSetting];
     factorChange = true;
     
      Serial.print(settingNames[currentSetting]);Serial.print(" set to ");Serial.println(routineSettings[currentRoutine][currentSetting]);
      Serial.print("currentRoutine ");Serial.println(currentRoutine);
     break;
     }
   case btnDOWN:
     {
     if (--routineSettings[currentRoutine][currentSetting] < 0)
      routineSettings[currentRoutine][currentSetting] = 0;
     factorChange = true;
      Serial.print(settingNames[currentSetting]);Serial.print(" set to ");Serial.println(routineSettings[currentRoutine][currentSetting]);
      Serial.print("currentRoutine ");Serial.println(currentRoutine);
     break;
     }
   case btnSELECT:
     {
     if (++currentSetting > 3)
      currentSetting = 0;
     settingChange = true;
     Serial.print("Current Selected Setting: ");Serial.println(settingNames[currentSetting]);
     break;
     }
     case btnNONE:
     {
     Serial.print("NONE  ");
     break;
     }
 }
}


void LED(int level, int row, int column, byte red, byte green, byte blue){ //****LED Routine****LED Routine****LED Routine****LED Routine
//This is where it all starts
//This routine is how LEDs are updated, with the inputs for the LED location and its R G and B brightness levels

// First, check and make sure nothing went beyond the limits, just clamp things at either 0 or 7 for location, and 0 or 15 for brightness
  if(level<0)
  level=0;
  if(level>7)
  level=7;
  if(row<0)
  row=0;
  if(row>7)
  row=7;
  if(column<0)
  column=0;
  if(column>7)
  column=7;  
    if(red<0)
  red=0;
  if(red>15)
  red=15;
  if(green<0)
  green=0;
  if(green>15)
  green=15;
  if(blue<0)
  blue=0;
  if(blue>15)
  blue=15;  
  
  
  //There are 512 LEDs in the cube, so when we write to level 2, column 5, row 4, that needs to be translated into a number from 0 to 511
  
  //This looks confusing, I know...
  int whichbyte = int(((level*64)+(row*8)+column)/8);
  
  // The first level LEDs are first in the sequence, then 2nd level, then third, and so on
  //the (level*64) is what indexes the level's starting place, so level 0 are LEDs 0-63, level 1 are LEDs 64-127, and so on
  
  //The column counts left to right 0-7 and the row is back to front 0-7
  //This means that if you had level 0, row 0, the bottom back row would count from 0-7, 
  
  //so if you looked down on the cube, and only looked at the bottom level
  // 00 01 02 03 04 05 06 07
  // 08 09 10 11 12 13 14 15
  // 16 17 18 19 20 21 22 23
  // 24 25 26 27 28 29 30 31
  // 32 33 34 35 36 37 38 39
  // 40 41 42 43 44 45 46 47  
  // 48 49 50 51 52 53 54 55  
  // 56 57 58 59 60 61 62 63

//Then, if you incremented the level, the top right of the grid above would start at 64
//The reason for doing this, is so you don't have to memorize a number for each LED, allowing you to use level, row, column

//Now, what about the divide by 8 in there?
//...well, we have 8 bits per byte, and we have 64 bytes in memory for all 512 bits needed for each LED, so
//we divide the number we just found by 8, and take the integ7er of it, so we know which byte, that bit is located
//confused? that's ok, let's take an example, if we wanted to write to the LED to the last LED in the cube, we would write a 7, 7, 7
// giving (7*64)+(7*8)=7 = 511, which is right, but now let's divide it by 8, 511/8 = 63.875, and take the int of it so, we get 63,
//this is the last byte in the array, which is right since this is the last LED
  
// This next variable is the same thing as before, but here we don't divide by 8, so we get the LED number 0-511
  int wholebyte=(level*64)+(row*8)+column;
//This will all make sense in a sec
 
 //This is 4 bit color resolution, so each color contains x4 64 byte arrays, explanation below:
  bitWrite(red0[whichbyte], wholebyte-(8*whichbyte), bitRead(red, 0));
  bitWrite(red1[whichbyte], wholebyte-(8*whichbyte), bitRead(red, 1));
  bitWrite(red2[whichbyte], wholebyte-(8*whichbyte), bitRead(red, 2)); 
  bitWrite(red3[whichbyte], wholebyte-(8*whichbyte), bitRead(red, 3)); 

  bitWrite(green0[whichbyte], wholebyte-(8*whichbyte), bitRead(green, 0));
  bitWrite(green1[whichbyte], wholebyte-(8*whichbyte), bitRead(green, 1));
  bitWrite(green2[whichbyte], wholebyte-(8*whichbyte), bitRead(green, 2)); 
  bitWrite(green3[whichbyte], wholebyte-(8*whichbyte), bitRead(green, 3));

  bitWrite(blue0[whichbyte], wholebyte-(8*whichbyte), bitRead(blue, 0));
  bitWrite(blue1[whichbyte], wholebyte-(8*whichbyte), bitRead(blue, 1));
  bitWrite(blue2[whichbyte], wholebyte-(8*whichbyte), bitRead(blue, 2)); 
  bitWrite(blue3[whichbyte], wholebyte-(8*whichbyte), bitRead(blue, 3));
  
//Are you now more confused?  You shouldn't be!  It's starting to make sense now.  Notice how each line is a bitWrite, which is,
//bitWrite(the byte you want to write to, the bit of the byte to write, and the 0 or 1 you want to write)
//This means that the 'whichbyte' is the byte from 0-63 in which the bit corresponding to the LED from 0-511
//Is making sense now why we did that? taking a value from 0-511 and converting it to a value from 0-63, since each LED represents a bit in 
//an array of 64 bytes.
//Then next line is which bit 'wholebyte-(8*whichbyte)'  
//This is simply taking the LED's value of 0-511 and subracting it from the BYTE its bit was located in times 8
//Think about it, byte 63 will contain LEDs from 504 to 511, so if you took 505-(8*63), you get a 1, meaning that,
//LED number 505 is is located in bit 1 of byte 63 in the array

//is that it?  No, you still have to do the bitRead of the brightness 0-15 you are trying to write,
//if you wrote a 15 to RED, all 4 arrays for that LED would have a 1 for that bit, meaning it will be on 100%
//This is why the four arrays read 0-4 of the value entered in for RED, GREEN, and BLUE
//hopefully this all makes some sense?

}//****LED routine end****LED routine end****LED routine end****LED routine end****LED routine end****LED routine end****LED routine end

ISR(TIMER1_COMPA_vect){//***MultiPlex BAM***MultiPlex BAM***MultiPlex BAM***MultiPlex BAM***MultiPlex BAM***MultiPlex BAM***MultiPlex BAM

//This routine is called in the background automatically at frequency set by OCR1A
//In this code, I set OCR1A to 30, so this is called every 124us, giving each level in the cube 124us of ON time
//There are 8 levels, so we have a maximum brightness of 1/8, since the level must turn off before the next level is turned on
//The frequency of the multiplexing is then 124us*8=992us, or 1/992us= about 1kHz


  PORTE |= 1<<blank_pin;//The first thing we do is turn all of the LEDs OFF, by writing a 1 to the blank pin
  //Note, in my bread-boarded version, I was able to move this way down in the cube, meaning that the OFF time was minimized
  //due to signal integrity and parasitic capcitance, my rise/fall times, required all of the LEDs to first turn off, before updating
  //otherwise you get a ghosting effect on the previous level

//This is 4 bit 'Bit angle Modulation' or BAM, There are 8 levels, so when a '1' is written to the color brightness, 
//each level will have a chance to light up for 1 cycle, the BAM bit keeps track of which bit we are modulating out of the 4 bits
//Bam counter is the cycle count, meaning as we light up each level, we increment the BAM_Counter
if(BAM_Counter==8)
BAM_Bit++;
else
if(BAM_Counter==24)
BAM_Bit++;
else
if(BAM_Counter==56)
BAM_Bit++;

BAM_Counter++;//Here is where we increment the BAM counter

switch (BAM_Bit){//The BAM bit will be a value from 0-3, and only shift out the arrays corresponding to that bit, 0-3
//Here's how this works, each case is the bit in the Bit angle modulation from 0-4, 
//Next, it depends on which level we're on, so the byte in the array to be written depends on which level, but since each level contains 64 LED,
//we only shift out 8 bytes for each color
case 0:
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(red0[shift_out]);
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(green0[shift_out]); 
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(blue0[shift_out]);
  break;
case 1:
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(red1[shift_out]);
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(green1[shift_out]); 
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(blue1[shift_out]);
  break;
 case 2:
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(red2[shift_out]);
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(green2[shift_out]); 
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(blue2[shift_out]);
 break;
 case 3:
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(red3[shift_out]);
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(green3[shift_out]); 
 for(shift_out=level; shift_out<level+8; shift_out++)
 SPI.transfer(blue3[shift_out]);
 //Here is where the BAM_Counter is reset back to 0, it's only 4 bit, but since each cycle takes 8 counts,
 //, it goes 0 8 16 32, and when BAM_counter hits 64 we reset the BAM
  if(BAM_Counter==120){
  BAM_Counter=0;
  BAM_Bit=0;
  }
  break;
}//switch_case

//SPI.transfer(anode[anodeLevel]);//finally, send out the anode level byte

// ** This routine selects layer without shift register. 
    lastAnode = (anodeLevel-1);
    if (anodeLevel == 0) { lastAnode = 7; } // if we are at the bottom, the last layer was the top
    digitalWrite(layerArray[lastAnode], HIGH); // turn off the previous layer
    digitalWrite(layerArray[anodeLevel], LOW); // turn on the current layer


PORTE |= 1<<latch_pin;//Latch pin HIGH
PORTE &= ~(1<<latch_pin);//Latch pin LOW
PORTE &= ~(1<<blank_pin);//Blank pin LOW to turn on the LEDs with the new data
// Blank is the same as the OE or ENABLE pin 

anodeLevel++;//inrement the anode level
level = level+8;//increment the level variable by 8, which is used to shift out data, since the next level woudl be the next 8 bytes in the arrays

if(anodeLevel==8)//go back to 0 if max is reached
anodeLevel=0;
if(level==64)//if you hit 64 on level, this means you just sent out all 63 bytes, so go back
level=0;
pinMode(blank_pin, OUTPUT);//moved down here so outputs are all off until the first call of this function
}//***MultiPlex BAM END***MultiPlex BAM END***MultiPlex BAM END***MultiPlex BAM END***MultiPlex BAM END***MultiPlex BAM END***MultiPlex BAM END



//*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE
//*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE
//*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE
//*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE*+*+*+*+*+*+*+*+*+*+*+*+PUT ANIMATIONS DOWN HERE

void glowingCube(int* settings) {
  clean();
  int upOrDown;
  int iterations = 500 * pow(2,settings[0]);
  int numberOfFrames = 17;
  bool edgeCurrentlyGlowing[numberOfFrames] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  //first 3 items are xyz of current glow location, 4th item indicates whether its x y or z that changes, 5th is which frame edge is currently on, 6th is direction of travel
  int edgeCurrentFrame[numberOfFrames][6] = {
    {0,0,0,2,0,1},
    {0,0,7,1,0,1},
    {0,7,7,2,0,-1},
    {0,7,0,1,0,-1},
    {0,0,0,0,0,1},
    {7,0,0,1,0,1},
    {7,7,0,2,0,1},
    {7,7,7,1,0,-1},
    {7,0,7,0,0,-1},
    {0,0,7,1,0,1},
    {0,7,7,0,0,1},
    {7,7,7,1,0,-1},
    {7,0,7,2,0,-1},
    {7,0,0,1,0,1},
    {7,7,0,0,0,-1},
    {0,7,0,1,0,-1},
    {0,0,0,2,0,1}};
  for (int i = 0; i < iterations; i++) {
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
    for (int j = 0; j < numberOfFrames; j++) {
      if (edgeCurrentlyGlowing[j] != 0) {
        if (edgeCurrentFrame[j][4] == 8) {
          LED(edgeCurrentFrame[j][0],edgeCurrentFrame[j][1],edgeCurrentFrame[j][2],0,0,0);
          edgeCurrentFrame[j][4] = 0;
          edgeCurrentlyGlowing[j] = 0;
          if (edgeCurrentFrame[j][5] == 1) {
            edgeCurrentFrame[j][edgeCurrentFrame[j][3]] = 0;
          } else {
            edgeCurrentFrame[j][edgeCurrentFrame[j][3]] = 7;
          }
          if (j != numberOfFrames-1) {
            edgeCurrentlyGlowing[j+1] = true;
            //edgeCurrentFrame[j+1][edgeCurrentFrame[j+1][3]] = 1;
          }
          break;
        }
        if (edgeCurrentFrame[j][4] == 0) {
          LED(edgeCurrentFrame[j][0],edgeCurrentFrame[j][1],edgeCurrentFrame[j][2],random(16),random(16),random(16));
        } else {
          LED(edgeCurrentFrame[j][0],edgeCurrentFrame[j][1],edgeCurrentFrame[j][2],0,0,0);
          edgeCurrentFrame[j][edgeCurrentFrame[j][3]] += edgeCurrentFrame[j][5];
          LED(edgeCurrentFrame[j][0],edgeCurrentFrame[j][1],edgeCurrentFrame[j][2],random(16),random(16),random(16));
          //LED(edgeCurrentFrame[j][0],edgeCurrentFrame[j][1],edgeCurrentFrame[j][2],colorSets[settings[3]][edgeCurrentFrame[j][4]][0],colorSets[settings[3]][edgeCurrentFrame[j][4]][1],colorSets[settings[3]][edgeCurrentFrame[j][4]][2]);
        }
        edgeCurrentFrame[j][4]++;
      } else {
        if (random(240) >= 243 - settings[1]) {
            edgeCurrentlyGlowing[j] = true;
        }
      }
    }
    delay(50);
  }
  clean();
}

void dancingCube(int* settings) {
  clean();
  int iterations = 20 * pow(2,settings[0]);
  int numberOfPoints = sizeof(smallCube)/sizeof(smallCube[0]);
  float cube[numberOfPoints][4];
  float transformedCube[numberOfPoints][4];
  for (int runs = 0; runs < iterations; runs++) {
    byte R = random(16), G = random(16), B = random(16);
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
    CopyFloatMatrix((float*)smallCube, numberOfPoints, 4, (float*)cube);
    displayObject((float*) cube,numberOfPoints, R,G,B);
    delay(100*pow(2,settings[1]-6));
    int delayFactor = 50  *pow(2,settings[1]-6);
    for (int i = 0; i < dancingCubeTransformSteps; i++) {
      if (interrupted) {
        interruptRoutine(true);
        return;
      }
      MultiplyFloatMatrixPROGMEM((float*)cube, (float*)dancingCubeTransforms[i], numberOfPoints, 4, 4, (float*)transformedCube);
      
      
      drawLines((float*)transformedCube, (int*)cubeAdjacency, numberOfPoints,R,G,B);
      drawLines((float*)cube, (int*)cubeAdjacency, numberOfPoints,0,0,0);
      CopyFloatMatrix((float*)transformedCube, numberOfPoints, 4, (float*)cube);
      delay(delayFactor);
    }
    clean();
  }
}
const byte hyperCubePoints[120][3] PROGMEM = {
  {0,0,0},{0,0,1},{0,0,2},{0,0,3},{0,0,4},{0,0,5},{0,0,6},{0,0,7},
  {0,1,0},{0,2,0},{0,3,0},{0,4,0},{0,5,0},{0,6,0},{0,7,0},
  {1,0,0},{2,0,0},{3,0,0},{4,0,0},{5,0,0},{6,0,0},{7,0,0},
  {7,7,7},{7,7,6},{7,7,5},{7,7,4},{7,7,3},{7,7,2},{7,7,1},{7,7,0},
  {7,6,7},{7,5,7},{7,4,7},{7,3,7},{7,2,7},{7,1,7},{7,0,7},
  {6,7,7},{5,7,7},{4,7,7},{3,7,7},{2,7,7},{1,7,7},{0,7,7},
  {1,0,7},{2,0,7},{3,0,7},{4,0,7},{5,0,7},{6,0,7},
  {1,7,0},{2,7,0},{3,7,0},{4,7,0},{5,7,0},{6,7,0},
  {7,1,0},{7,2,0},{7,3,0},{7,4,0},{7,5,0},{7,6,0},
  {7,0,1},{7,0,2},{7,0,3},{7,0,4},{7,0,5},{7,0,6},
  {0,1,7},{0,2,7},{0,3,7},{0,4,7},{0,5,7},{0,6,7},
  {0,7,1},{0,7,2},{0,7,3},{0,7,4},{0,7,5},{0,7,6},
  {2,2,2},{2,3,2},{2,4,2},{2,5,2},
  {3,2,2},{4,2,2},{5,2,2},
  {2,2,3},{2,2,4},{2,2,5},
  {5,5,5},{4,5,5},{3,5,5},{2,5,5},
  {5,4,5},{5,3,5},{5,2,5},
  {5,5,4},{5,5,3},{5,5,2},
  {2,5,4},{2,5,3},
  {2,4,5},{2,3,5},
  {5,2,4},{5,2,3},
  {5,3,2},{5,4,2},
  {3,2,5},{4,2,5},
  {3,5,2},{4,5,2},
  {1,1,1},{1,6,1},{1,6,6},{1,1,6},{6,1,1},{6,6,1},{6,6,6},{6,1,6}
};
void hyperCube(int* settings) { 
  clean();
  bool firstRun = true;
  byte startingColor[3];
  byte oldStartingColor[3];
  int duration = random(1,4)*10*(settings[0]+1);
  for (int runs = 0; runs < duration; runs++) {
    //0 = y 1 = x 2 = z
    byte colorShiftDirection = random(3);
    byte colorSet = random(numberOfColorSets);
    bool colorDirection = random(1);
    startingColor[0] = pgm_read_word_near(&colorSets[colorSet][colorDirection? 7 : 0][0]);
    startingColor[1] = pgm_read_word_near(&colorSets[colorSet][colorDirection? 7 : 0][1]);
    startingColor[2] = pgm_read_word_near(&colorSets[colorSet][colorDirection? 7 : 0][2]);
    if (!firstRun) {
      for (int frame = 0; frame < 6; frame++) {
        int R = map(frame,0,6,oldStartingColor[0],startingColor[0]);
        int G = map(frame,0,6,oldStartingColor[1],startingColor[1]);
        int B = map(frame,0,6,oldStartingColor[2],startingColor[2]);
        for (int i = 0; i < 120; i++) {
            LED(pgm_read_byte_near(&hyperCubePoints[i][0]),pgm_read_byte_near(&hyperCubePoints[i][1]),pgm_read_byte_near(&hyperCubePoints[i][2]),R,G,B);
        }
        delay(150);
      }
    } else {
      for (int i = 0; i < 120; i++) {
          LED(pgm_read_byte_near(&hyperCubePoints[i][0]),pgm_read_byte_near(&hyperCubePoints[i][1]),pgm_read_byte_near(&hyperCubePoints[i][2]),startingColor[0],startingColor[1],startingColor[2]);
      }
    }
    firstRun = false;
    int yShift;
    delay(2000*random(1,4));
    for (int frame = 7; frame > -8; frame--) {
      for (int i = 0; i < 120; i++) {
        int xyzPosition = pgm_read_byte_near(&hyperCubePoints[i][colorShiftDirection]);
        if (colorDirection) {
          yShift = xyzPosition + frame > 7 ? 7 : xyzPosition + frame;
        } else {
          yShift = xyzPosition - frame > 7 ? 7 : xyzPosition - frame;
        }
          yShift = yShift < 0 ? 0 : yShift;
          LED(pgm_read_byte_near(&hyperCubePoints[i][0]),pgm_read_byte_near(&hyperCubePoints[i][1]),pgm_read_byte_near(&hyperCubePoints[i][2]),pgm_read_word_near(&colorSets[colorSet][yShift][0]),pgm_read_word_near(&colorSets[colorSet][yShift][1]),pgm_read_word_near(&colorSets[colorSet][yShift][2]));
      }
      delay(150);
      if (frame == -7) {
        startingColor[0] = pgm_read_word_near(&colorSets[colorSet][yShift][0]);
        startingColor[1] = pgm_read_word_near(&colorSets[colorSet][yShift][1]);
        startingColor[2] = pgm_read_word_near(&colorSets[colorSet][yShift][2]);
      }
    }
    delay(2000*random(1,4));
    oldStartingColor[0] = startingColor[0];
    oldStartingColor[1] = startingColor[1];
    oldStartingColor[2] = startingColor[2];
    if (random(1000) < 30) {
      for (int runs = 0; runs < 300; runs++) {
        for (int i = 0; i < 120; i++) {
            LED(pgm_read_byte_near(&hyperCubePoints[i][0]),pgm_read_byte_near(&hyperCubePoints[i][1]),pgm_read_byte_near(&hyperCubePoints[i][2]),random(13),random(16),random(16));
        }
      }
    }
  }
}

void rubiksCube(int* options) {
  //0 = right 1 = left 2 = front 3 = back 4 = top 5 =bottom faces
  int faceStickers[6][3][3];
  for (int i = 0; i < 6; i++){
    for (int j=0; j< 3; j++) {
       for (int k=0; k< 3; k++) {
      faceStickers[i][j][k] = i;
       }
    }
  }
  displayRubiksCube((int*)faceStickers);
  if (interrupted) {
    interruptRoutine(true);
    return;
  }
  delay(2000);
  int newStickers[6][3][3];
  byte iterations = random(40);
  int rotations[40];
  bool directions[40];
  for (int x = 0; x < 5*(options[0]+1); x++) {
    iterations = random(40);
  int rotations[40];
  for (int i = 0; i < iterations; i++) {
     if (interrupted) {
      interruptRoutine(true);
      return;
    }
    rotations[i] = random(6);
    directions[i] = random(1);
    rotateCube((int*)faceStickers, (int*) newStickers, rotations[i], directions[i]);
    for (int i=0; i< 6; i++) {
      for (int j = 0; j < 3;j++) {
        for (int k = 0; k < 3; k++) {
          faceStickers[i][j][k] = newStickers[i][j][k];
        }
      }
    }
    rubiksCleanup();
    displayRubiksCube((int*)newStickers);
  }
  for (int i = 0; i < iterations; i++) {
     if (interrupted) {
      interruptRoutine(true);
      return;
    }
    rotateCube((int*)faceStickers, (int*) newStickers, rotations[iterations-1-i], !directions[iterations-1-i]);
    for (int i=0; i< 6; i++) {
      for (int j = 0; j < 3;j++) {
        for (int k = 0; k < 3; k++) {
          faceStickers[i][j][k] = newStickers[i][j][k];
        }
      }
    }
    rubiksCleanup();
    displayRubiksCube((int*)newStickers);
    //delay(1000);
  }
  delay(5000);
  }
  clean();
}

    byte colorTranslator[6][3] = {{7,15,0},{8,15,15},{10,4,0},{0,0,15},{0,15,0},{15,0,0}};
//0 = right 1 = left 2 = front 3 = back 4 = top 5 =bottom faces
  int sideDisplayTransforms[6][4][4] = {
    {{1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,7,0,1}},
    {{1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,7,1}},
    {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}},
    {{1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,7,7,1}},
    {{0,0,1,0},{0,1,0,0},{-1,0,0,0},{7,0,0,1}},
    {{0,0,-1,0},{0,1,0,0},{1,0,0,0},{0,0,7,1}}
  };
  //row.position.LEDNo.xyz
  int stickerLEDPositions[3][3][4][4] = {
    {
      {{6,1,0,1},{6,2,0,1},{5,1,0,1},{5,2,0,1}},
      {{6,3,0,1},{6,4,0,1},{5,3,0,1},{5,4,0,1}},
      {{6,5,0,1},{6,6,0,1},{5,5,0,1},{5,6,0,1}}
    },
    {
      {{4,1,0,1},{4,2,0,1},{3,1,0,1},{3,2,0,1}},
      {{4,3,0,1},{4,4,0,1},{3,3,0,1},{3,4,0,1}},
      {{4,5,0,1},{4,6,0,1},{3,5,0,1},{3,6,0,1}}
    },
    {
      {{2,1,0,1},{2,2,0,1},{1,1,0,1},{1,2,0,1}},
      {{2,3,0,1},{2,4,0,1},{1,3,0,1},{1,4,0,1}},
      {{2,5,0,1},{2,6,0,1},{1,5,0,1},{1,6,0,1}}
    }
  };
  //0 = right 1 = left 2 = front 3 = back 4 = top 5 =bottom faces
  byte originalStickersIndex[6][21] = {
    {0,1,2,3,4,5,6,7,8,20,23,26,27,30,33,38,41,44,47,50,53},
    {9,10,11,12,13,14,15,16,17,18,21,24,29,32,35,36,39,42,45,48,51},
    {18,19,20,21,22,23,24,25,26,0,3,6,11,14,17,42,43,44,45,46,47},
    {27,28,29,30,31,32,33,34,35,2,5,8,9,12,15,36,37,38,51,52,53},
    {36,37,38,39,40,41,42,43,44,18,19,20,27,28,29,0,1,2,9,10,11},
    {45,46,47,48,49,50,51,52,53,6,7,8,15,16,17,24,25,26,33,34,35}
  };
  //indexes to swap with if CW
  const byte swapIndex[6][21] PROGMEM = {
    {6,3,0,7,4,1,8,5,2,47,50,53,38,41,44,20,23,26,27,30,33},
    {15,12,9,16,13,10,17,14,11,36,39,42,45,48,51,29,32,35,18,21,24},
    {24,21,18,25,22,19,26,23,20,42,43,44,45,46,47,11,14,17,0,3,6},
    {33,30,27,34,31,28,35,32,29,51,52,53,36,37,38,2,5,8,9,12,15},
    {42,39,36,43,40,37,44,41,38,0,1,2,9,10,11,27,28,29,18,19,20},
    {51,48,45,52,49,46,53,50,47,24,25,26,33,34,35,15,16,17,6,7,8}
  };
void displayRubiksCube(int* faceStickers) {
  for (int i = 0; i < 6; i++){
  for (int j=0; j< 3; j++) {
     for (int k=0; k< 3; k++) {
        int LEDPositions[4][4];
        MultiplyIntMatrix((int*)stickerLEDPositions[j][k], (int*)sideDisplayTransforms[i], 4,4,4, (int*)LEDPositions);
        //delay(1000);
        for (int l=0; l < 4; l++) {
          int stickerColor = faceStickers[(9*i)+(3*j)+k];//faceStickers[i][j][k];
          LED(LEDPositions[l][0],LEDPositions[l][1],LEDPositions[l][2],colorTranslator[stickerColor][0],colorTranslator[stickerColor][1],colorTranslator[stickerColor][2]);
          //
        }
     }
  }
}
}
//faceStickers[6][3][3];
//0 = right 1 = left 2 = front 3 = back 4 = top 5 =bottom faces
void rotateCube(int* oldPositions, int* newPositions, int sideToRotate, bool CW) {
  for (int i = 0; i < 54; i++) {
    newPositions[i] = oldPositions[i];
  }
  for (int i =0; i < 21; i++) {
    if (CW)
      newPositions[originalStickersIndex[sideToRotate][i]] = oldPositions[pgm_read_byte_near(&swapIndex[sideToRotate][i])];
     else
      newPositions[pgm_read_byte_near(&swapIndex[sideToRotate][i])] = oldPositions[originalStickersIndex[sideToRotate][i]];
  }
  //precompute frames for animation
  //5 frames for animation, 84 LEDs are moving,4 ints for y,x,z,1
  //converted the middle 3 frame data to bytes to save memory
  byte frames[3][84][4];
  int firstFrame[84][4];
  byte LEDColors[21];
  //21 stickers moving
  for (int i =0; i < 21; i++) {
     int LEDPositions[4][4];
     MultiplyIntMatrix((int*)stickerLEDPositions[(originalStickersIndex[sideToRotate][i]%9)/3][originalStickersIndex[sideToRotate][i]%3], (int*)sideDisplayTransforms[originalStickersIndex[sideToRotate][i]/9], 4,4,4, (int*)LEDPositions);
     for (int j=0;j<4;j++) {
      for (int k = 0; k < 4; k++) {
          firstFrame[i*4+j][k] = LEDPositions[j][k];
      }
        LEDColors[i] = oldPositions[originalStickersIndex[sideToRotate][i]];
     }
  }
  if (!CW) {
    switch (sideToRotate) {
      case 0:
        sideToRotate = 1;
        break;
      case 1:
        sideToRotate = 0;
        break;
      case 2:
        sideToRotate = 3;
        break;
      case 3:
        sideToRotate = 2;
        break;
      case 4:
        sideToRotate = 5;
        break;
      case 5:
        sideToRotate = 4;
        break;
    }
  }
   for (int i=0;i<3;i++) {
    //holder of float values before rounding to int
    float frameData[5][4];
    for (int x = 0; x < 16; x++) {
      MultiplyIntAndFloatMatrixPROGMEM((int*)firstFrame[x*5],(float*)rubiksRotations[sideToRotate][i],5,4,4,(float*)frameData);
      for (int j = x*5; j < (x+1)*5; j++) {
        for (int k = 0; k < 4; k++) {
          //round float to byte
          int voxelPosition = (int)(frameData[j-(x*5)][k] + 0.5);
          frames[i][j][k] = (byte)voxelPosition;
        }
       }
    }
    MultiplyIntAndFloatMatrixPROGMEM((int*)firstFrame[80],(float*)rubiksRotations[sideToRotate][i],5,4,4,(float*)frameData);
    for (int j = 80; j < 84; j++) {
      for (int k = 0; k < 4; k++) {
        //round float to byte
        int voxelPosition = (int)(frameData[j-80][k] + 0.5);
        frames[i][j][k] = (byte)voxelPosition;
      }
     }
   }
   //printMatrix((int*)frames[1],8,4);
    for (int j = 0; j < 84; j++) {
      LED(firstFrame[j][0],firstFrame[j][1],firstFrame[j][2],colorTranslator[LEDColors[j/4]][0],colorTranslator[LEDColors[j/4]][1],colorTranslator[LEDColors[j/4]][2]);
    }
    delay(80);
    for (int i = 0; i < 3; i++) {
      rubiksCleanup();
      for (int j = 0; j < 84; j++) {
        LED(frames[i][j][0],frames[i][j][1],frames[i][j][2],colorTranslator[LEDColors[j/4]][0],colorTranslator[LEDColors[j/4]][1],colorTranslator[LEDColors[j/4]][2]);
      }
      delay(80);
    }
}
//LED(frames[0][i][0],frames[0][i][1],frames[0][i][2],colorTranslator[LEDColors[i/4]][0],colorTranslator[LEDColors[i/4]][1],colorTranslator[LEDColors[i/4]][2]);
  

void rubiksCleanup() {
  for (int i = 0; i < 7; i++) {
    LED(0,0,i,0,0,0);
    LED(0,7,i,0,0,0);
    LED(0,i,0,0,0,0);
    LED(0,i,7,0,0,0);
    LED(7,0,i,0,0,0);
    LED(7,7,i,0,0,0);
    LED(7,i,0,0,0,0);
    LED(7,i,7,0,0,0);
    LED(i,0,0,0,0,0);
    LED(i,7,0,0,0,0);
    LED(i,0,7,0,0,0);
    LED(i,7,7,0,0,0);
    if (i > 0)
      for (int j = 1; j < 7; j++) {
        for (int k = 1; k < 7; k++) {
          LED(i,j,k,0,0,0);
        }
      }
  }
}

  // LED (y,x,z,r,g,b) if facing front
//  int sidePositionFactor[6][3] = {
// each 3 array represents xyz of a side and how to transform from front facing LEDS
// 0 = always 0
// 7 = always 7
//1,2,3 = look at y,x,zrespectively of original coordinates toget this value
//    {1,7,2},{1,0,2},{1,2,0},{1,2,7),{7,2,1},{0,2,1}
//  }
//0 yellow 1 white 2 orange 3 blue 4 green 5 red


void printMatrix(int* matrixToPrint, int len, int width) {
  int matrix[len][width];
  CopyIntMatrix((int*)matrixToPrint, len, width, (int*)matrix);
  Serial.println("Printing matrix:");
  Serial.println("{");
  for (int i = 0; i < len; i++) {
    Serial.print("  {");
    for (int j = 0; j < width; j++) {
      Serial.print(matrix[i][j]);Serial.print(",");
    }
    Serial.println("},");
  }
  Serial.println("}");
}

void printFloatMatrix(float* A, int m, int n, String label)
{
 // A = input matrix (m x n)
  int i, j;
  Serial.println();
  Serial.println(label);
  for (i = 0; i < m; i++)
  {
    for (j = 0; j < n; j++)
    {
      Serial.print(A[n * i + j]);
      Serial.print("\t");
    }
    Serial.println();
  }
}

//*****Fireworks*****Fireworks*****Fireworks*****Fireworks*****Fireworks*****Fireworks*****Fireworks*****Fireworks*****Fireworks*****Fireworks***

void fireworks (int iterations, int n, int delayx, int* settings)
{
  clean;
  iterations *= pow(2,settings[0]);
  n *= 0.1 * (settings[1] + 4);
  Serial.println("n = ");
  Serial.println(n);
  Serial.print("iterations = ");Serial.println(iterations);
  int i,f,e,x;

  float origin_x = 3;
  float origin_y = 3;
  float origin_z = 3;

  int rand_y, rand_x, rand_z;

  float slowrate, gravity;

  // Particles and their position, x,y,z and their movement, dx, dy, dz
  float particles[n][6];
        float lastpart[n][3];

  for (i=0; i<iterations; i++)
  {

    origin_x = rand()%4;
    origin_y = rand()%4;
    origin_z = rand()%2;
    origin_z +=5;
        origin_x +=2;
        origin_y +=2;
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
    // shoot a particle up in the air
    for (e=0;e<origin_z;e++)
    {
      LED (e,origin_x,origin_y,(random(16)),(random(16)),(random(16)));
      x=(50*e);
                        delay(30);
      clean();
    }

    // Fill particle array
    for (f=0; f<n; f++)
    {
      // Position
      particles[f][0] = origin_x;
      particles[f][1] = origin_y;
      particles[f][2] = origin_z;
      
      rand_x = rand()%200;
      rand_y = rand()%200;
      rand_z = rand()%200;

      // Movement
      particles[f][3] = 1-(float)rand_x/100; // dx
      particles[f][4] = 1-(float)rand_y/100; // dy
      particles[f][5] = 1-(float)rand_z/100; // dz
    }

    // explode
    for (e=0; e<25; e++)
    {
      slowrate = 1+tan((e+0.1)/20)*10;
      
      gravity = tan((e+0.1)/20)/2;


      for (f=0; f<n; f++)
      {
        
                                particles[f][0] += particles[f][3]/slowrate;
        particles[f][1] += particles[f][4]/slowrate;
        particles[f][2] += particles[f][5]/slowrate;
        particles[f][2] -= gravity;
                                
        
                                LED (particles[f][2],particles[f][0],particles[f][1],(random(16)),(random(16)),(random(16)));
                                lastpart[f][2]=particles[f][2];
                                lastpart[f][0]=particles[f][0];
                                lastpart[f][1]=particles[f][1];

      }

    delay(40);
                  for (f=0; f<n; f++)
            {
        LED (lastpart[f][2],lastpart[f][0],lastpart[f][1],0,0,0);      
    }


  }

}}


//**************************************************************************************************************************


void wipe_out(){//*****wipe_out*****wipe_out*****wipe_out*****wipe_out*****wipe_out*****wipe_out*****wipe_out*****wipe_out
  int xxx=0, yyy=0, zzz=0;
  int fx=random(8), fy=random(8), fz=random(8), direct, fxm=1, fym=1, fzm=1, fxo=0, fyo=0, fzo=0;
  int  ftx=random(8), fty=random(8), ftz=random(8), ftxm=1, ftym=1, ftzm=1, ftxo=0, ftyo=0, ftzo=0;
  int select, rr, gg, bb, rrt, ggt, bbt;
  for(xxx=0; xxx<8; xxx++){
  for(yyy=0; yyy<8; yyy++){
  for(zzz=0; zzz<8; zzz++){
  LED(xxx, yyy, zzz, 0, 0, 0);
  }}}
  
       select=random(3);
    if(select==0){
      rr=random(1, 16);
      gg=random(1, 16);
      bb=0;} 
     if(select==1){
      rr=random(1, 16);
      gg=0;
      bb=random(1, 16);}    
     if(select==2){
      rr=0;
      gg=random(1, 16);
      bb=random(1, 16);}
      
       select=random(3);
    if(select==0){
      rrt=random(1, 16);
      ggt=random(1, 16);
      bbt=0;} 
     if(select==1){
      rrt=random(1, 16);
      ggt=0;
      bbt=random(1, 16);}    
     if(select==2){
      rrt=0;
      ggt=random(1, 16);
      bbt=random(1, 16);}  
        start=millis();
      
  while(millis()-start<100000){
        if (interrupted) {
      interruptRoutine(true);
      return;
    }
    //fx=random(8); fy=random(8); fz=random(8);

    LED(fxo, fyo, fzo, 0, 0, 0);
    LED(fxo, fyo, fzo+1, 0, 0, 0);
    LED(fxo, fyo, fzo-1, 0, 0, 0);
    LED(fxo+1, fyo, fzo, 0, 0, 0);
    LED(fxo-1, fyo, fzo, 0, 0, 0);
    LED(fxo, fyo+1, fzo, 0, 0, 0);
    LED(fxo, fyo-1, fzo, 0, 0, 0);
    
    LED(ftxo, ftyo, ftzo, 0, 0, 0);
    LED(ftxo, ftyo, ftzo+1, 0, 0, 0);
    LED(ftxo, ftyo, ftzo-1, 0, 0, 0);
    LED(ftxo+1, ftyo, ftzo, 0, 0, 0);
    LED(ftxo-1, ftyo, ftzo, 0, 0, 0);
    LED(ftxo, ftyo+1, ftzo, 0, 0, 0);
    LED(ftxo, ftyo-1, ftzo, 0, 0, 0);

    LED(ftx, fty, ftz, rr, gg, bb);
    LED(ftx, fty, ftz+1, rr, gg, bb);
    LED(ftx, fty, ftz-1,  rr, gg, bb);
    LED(ftx+1, fty, ftz, rr, gg, bb);
    LED(ftx-1, fty, ftz, rr, gg, bb);
    LED(ftx, fty+1, ftz, rr, gg, bb);
    LED(ftx, fty-1, ftz, rr, gg, bb);     
    
    LED(fx, fy, fz, rrt, ggt, bbt);
    LED(fx, fy, fz+1, rrt, ggt, bbt);
    LED(fx, fy, fz-1, rrt, ggt, bbt);
    LED(fx+1, fy, fz, rrt, ggt, bbt);
    LED(fx-1, fy, fz, rrt, ggt, bbt);
    LED(fx, fy+1, fz, rrt, ggt, bbt);
    LED(fx, fy-1, fz, rrt, ggt, bbt);  
    
    
     delay(10);
     
    fxo=fx;
    fyo=fy;
    fzo=fz; 
    
    ftxo=ftx;
    ftyo=fty;
    ftzo=ftz; 
 
    direct=random(3);
    if(direct==0)
    fx= fx+fxm;
    if(direct==1)
    fy= fy+fym;  
    if(direct==2)
    fz= fz+fzm;  
  if(fx<0){
    fx=0; fxm=1;}
  if(fx>7){
    fx=7; fxm=-1;}  
  if(fy<0){
    fy=0; fym=1;}
  if(fy>7){
    fy=7; fym=-1;}    
  if(fz<0){
    fz=0; fzm=1;}
  if(fz>7){
    fz=7; fzm=-1;}  
  
      direct=random(3);
    if(direct==0)
    ftx= ftx+ftxm;
    if(direct==1)
    fty= fty+ftym;  
    if(direct==2)
    ftz= ftz+ftzm;  
  if(ftx<0){
    ftx=0; ftxm=1;}
  if(ftx>7){
    ftx=7; ftxm=-1;}  
  if(fty<0){
    fty=0; ftym=1;}
  if(fty>7){
    fty=7; ftym=-1;}    
  if(ftz<0){
    ftz=0; ftzm=1;}
  if(ftz>7){
    ftz=7; ftzm=-1;} 
  }//while
    for(xxx=0; xxx<8; xxx++){
  for(yyy=0; yyy<8; yyy++){
  for(zzz=0; zzz<8; zzz++){
  LED(xxx, yyy, zzz, 0, 0, 0);
  }}}
  
}//wipeout


void rainVersionTwo(int* settings){//****rainVersionTwo****rainVersionTwo****rainVersionTwo****rainVersionTwo****rainVersionTwo
  int x[64], y[64], z[64], addr, leds=64*0.1*(settings[1]+4), bright=1, ledcolor, colowheel;
  int xx[64], yy[64], zz[64], xold[64], yold[64], zold[64], slowdown;
  int delayFactor = 15 * (64/leds);
  
  for(addr=0; addr<64; addr++){
    x[addr]=random(8);
    y[addr]=random(8);
    z[addr]=random(8);
    xx[addr]=random(16);
    yy[addr]=random(16);
    zz[addr]=random(16);     
  }
  start=millis();
  while(millis()-start<(30000*pow(2,settings[0]))){
  //wipe_out();
  //for(addr=0; addr<leds; addr++)
  //LED(zold[addr], xold[addr], yold[addr], 0, 0, 0);
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
if(ledcolor<200){
  for(addr=0; addr<leds; addr++){
    LED(zold[addr], xold[addr], yold[addr], 0, 0, 0);
//  Serial.println(z[addr]);
//  Serial.println(x[addr]);
//  Serial.println(y[addr]);
//  Serial.println();
  if(z[addr]>=7)
  LED(z[addr], x[addr], y[addr], 0, 5, 15);
  if(z[addr]==6)
  LED(z[addr], x[addr], y[addr], 0, 1, 9);
   if(z[addr]==5)
  LED(z[addr], x[addr], y[addr], 0, 0, 10);
   if(z[addr]==4)
  LED(z[addr], x[addr], y[addr], 1, 0, 11); 
    if(z[addr]==3)
  LED(z[addr], x[addr], y[addr], 3, 0, 12);
    if(z[addr]==2)
  LED(z[addr], x[addr], y[addr], 10, 0, 15);
    if(z[addr]==1)
  LED(z[addr], x[addr], y[addr], 10, 0, 10);
    if(z[addr]<=0)
  LED(z[addr], x[addr], y[addr], 10, 0, 1);
}}//200

  if(ledcolor>=200&&ledcolor<300){
  for(addr=0; addr<leds; addr++){
    LED(zold[addr], xold[addr], yold[addr], 0, 0, 0);
  if(z[addr]>=7)
  LED(z[addr], x[addr], y[addr], 15, 15, 0);
  if(z[addr]==6)
  LED(z[addr], x[addr], y[addr], 10, 10, 0);
   if(z[addr]==5)
  LED(z[addr], x[addr], y[addr], 15, 5, 0);
   if(z[addr]==4)
  LED(z[addr], x[addr], y[addr], 15, 2, 0); 
    if(z[addr]==3)
  LED(z[addr], x[addr], y[addr], 15, 1, 0);
    if(z[addr]==2)
  LED(z[addr], x[addr], y[addr], 15, 0, 0);
    if(z[addr]==1)
  LED(z[addr], x[addr], y[addr], 12, 0, 0);
    if(z[addr]<=0)
  LED(z[addr], x[addr], y[addr], 10, 0, 0);
}}//300

    if(ledcolor>=300&&ledcolor<400){

  }
     if(ledcolor>=500&&ledcolor<600){

}
  
  
  ledcolor++;
if(ledcolor>=300)
ledcolor=0;
  
    for(addr=0; addr<leds; addr++){
    xold[addr]=x[addr];
    yold[addr]=y[addr];
    zold[addr]=z[addr];
   } 
  
  
  delay(delayFactor);
  
  //for(addr=0; addr<leds; addr++)
  //LED(z[addr], x[addr], y[addr], 0, 0, 0);
    for(addr=0; addr<leds; addr++){
      
      //slowdown = random(2);
      //if(bitRead(z[addr],0))
  z[addr] = z[addr]-1;
  
 // x[addr] = x[addr]+1;
 // y[addr] = y[addr]+1;
  if(z[addr]<random(-100,0)){
    x[addr]=random(8);
    y[addr]=random(8);
    int select=random(3);
    if(select==0){
    xx[addr]=0;
    zz[addr]=random(16);
    yy[addr]=random(16);
    //zz[addr]=0;
    }
    if(select==1){
    xx[addr]=random(16);
    zz[addr]=0;
    yy[addr]=random(16);
    //yy[addr]=0;
    }
    if(select==2){
    xx[addr]=random(16);
    zz[addr]=random(16);
    yy[addr]=0;
    
    
    }    
   z[addr]=7; 
   
  }//-check
  }//add

  
  }//while
 
}//rainv2

void folder(int* settings){//****folder****folder****folder****folder****folder****folder****folder****folder****folder
  int xx, yy, zz, pullback[16], state=0, backorfront=7;//backorfront 7 for back 0 for front
  
  int folderaddr[16], LED_Old[16], oldpullback[16], ranx=random(16), rany=random(16), ranz=random(16), ranselect;
  int bot=0, top=1, right=0, left=0, back=0, front=0, side=0, side_select;
  
  folderaddr[0]=-7;
  folderaddr[1]=-6;
  folderaddr[2]=-5;
  folderaddr[3]=-4;
  folderaddr[4]=-3;
  folderaddr[5]=-2;
  folderaddr[6]=-1;
  folderaddr[7]=0;
  
  for(xx=0; xx<8; xx++){
  oldpullback[xx]=0;
  pullback[xx]=0;
  }
  
  
  
  start=millis();
  while(millis()-start<50000*pow(2,settings[0])){ 
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
    if(top==1){
      if(side==0){
   //top to left-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(7-LED_Old[yy], yy-oldpullback[yy],xx , 0, 0, 0);
  LED(7-folderaddr[yy], yy-pullback[yy],xx , ranx, rany, ranz);
  }}}
    if(side==2){
      //top to back-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(7-LED_Old[yy], xx, yy-oldpullback[yy], 0, 0, 0);
  LED(7-folderaddr[yy], xx, yy-pullback[yy], ranx, rany, ranz);
  }}}
  if(side==3){
      //top-side to front-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(7-LED_Old[7-yy], xx, yy+oldpullback[yy], 0, 0, 0);
  LED(7-folderaddr[7-yy], xx, yy+pullback[yy], ranx, rany, ranz);
  }}}
    if(side==1){
    //top-side to right
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(7-LED_Old[7-yy], yy+oldpullback[yy],xx , 0, 0, 0);
  LED(7-folderaddr[7-yy], yy+pullback[yy],xx , ranx, rany, ranz);
  }}}
    }//top
    
    if(right==1){
    if(side==4){
   //right-side to top
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy+oldpullback[7-yy],7-LED_Old[7-yy],xx , 0, 0, 0);
  LED( yy+pullback[7-yy],7-folderaddr[7-yy],xx , ranx, rany, ranz);
  }}}
    if(side==3){
    //right-side to front-side
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, 7-LED_Old[7-yy],yy+oldpullback[yy], 0, 0, 0);
  LED(xx,7-folderaddr[7-yy], yy+pullback[yy], ranx, rany, ranz);
  }}}
    if(side==2){
   //right-side to back-side
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, 7-LED_Old[yy],yy-oldpullback[yy], 0, 0, 0);
  LED(xx,7-folderaddr[yy], yy-pullback[yy], ranx, rany, ranz);
  }}}
    if(side==5){
    //right-side to bottom
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy-oldpullback[yy],7-LED_Old[yy],xx , 0, 0, 0);
  LED( yy-pullback[yy],7-folderaddr[yy],xx , ranx, rany, ranz);
  }}}
    }//right
    
 if(left==1){
    if(side==4){
   //left-side to top
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy+oldpullback[yy],LED_Old[7-yy],xx , 0, 0, 0);
  LED( yy+pullback[yy],folderaddr[7-yy],xx , ranx, rany, ranz);
  }}}
  if(side==3){
     //left-side to front-side
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, LED_Old[7-yy],yy+oldpullback[yy], 0, 0, 0);
  LED(xx,folderaddr[7-yy], yy+pullback[yy], ranx, rany, ranz);
  }}}
  if(side==2){
//left-side to back-side
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, LED_Old[yy],yy-oldpullback[yy], 0, 0, 0);
  LED(xx,folderaddr[yy], yy-pullback[yy], ranx, rany, ranz);
  }}}
  if(side==5){
  //left-side to bottom
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy-oldpullback[yy],LED_Old[yy],xx , 0, 0, 0);
  LED( yy-pullback[yy],folderaddr[yy],xx , ranx, rany, ranz);
  }}}
  }//left
  
  
   if(back==1){
    if(side==1){
  //back-side to right-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, yy+oldpullback[yy],LED_Old[7-yy], 0, 0, 0);
  LED(xx, yy+pullback[yy],folderaddr[7-yy], ranx, rany, ranz);
  }}}
  if(side==4){
  // back-side to top-side
    for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy+oldpullback[yy],xx,LED_Old[7-yy] , 0, 0, 0);
  LED( yy+pullback[yy],xx,folderaddr[7-yy] , ranx, rany, ranz);
  }}}
  if(side==5){
  // back-side to bottom
    for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy-oldpullback[yy],xx,LED_Old[yy] , 0, 0, 0);
  LED( yy-pullback[yy],xx,folderaddr[yy] , ranx, rany, ranz);
  }}}//state1
 if(side==0){
//back-side to left-side
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, yy-oldpullback[yy],LED_Old[yy], 0, 0, 0);
  LED(xx, yy-pullback[yy],folderaddr[yy], ranx, rany, ranz);
  }}}
   }//back
   if(bot==1){
    if(side==1){
    // bottom-side to right-side
      for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(LED_Old[7-yy], yy+oldpullback[yy],xx , 0, 0, 0);
  LED(folderaddr[7-yy], yy+pullback[yy],xx , ranx, rany, ranz);
  }}}
  if(side==3){
  //bottom to front-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(LED_Old[7-yy], xx, yy+oldpullback[yy], 0, 0, 0);
  LED(folderaddr[7-yy], xx, yy+pullback[yy], ranx, rany, ranz);
  }}}
if(side==2){
  //bottom to back-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(LED_Old[yy], xx, yy-oldpullback[yy], 0, 0, 0);
  LED(folderaddr[yy], xx, yy-pullback[yy], ranx, rany, ranz);
  }}}
if(side==0){
  //bottom to left-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(LED_Old[yy], yy-oldpullback[yy],xx , 0, 0, 0);
  LED(folderaddr[yy], yy-pullback[yy],xx , ranx, rany, ranz);
  }}}
   }//bot
   
    if(front==1){
   if(side==0){
    //front-side to left-side
   for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, yy-oldpullback[yy],7-LED_Old[yy], 0, 0, 0);
  LED(xx, yy-pullback[yy],7-folderaddr[yy], ranx, rany, ranz);
  }}}
  if(side==5){
      // front-side to bottom
    for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy-oldpullback[yy],xx,7-LED_Old[yy] , 0, 0, 0);
  LED( yy-pullback[yy],xx,7-folderaddr[yy] , ranx, rany, ranz);
  }}}
  if(side==4){
      // front-side to top-side
    for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(yy+oldpullback[yy],xx,7-LED_Old[7-yy] , 0, 0, 0);
  LED( yy+pullback[yy],xx,7-folderaddr[7-yy] , ranx, rany, ranz);
  }}}
  if(side==1){
      //front-side to right-side
  for(yy=0; yy<8; yy++){
  for(xx=0; xx<8; xx++){
  LED(xx, yy+oldpullback[yy],7-LED_Old[7-yy], 0, 0, 0);
  LED(xx, yy+pullback[yy],7-folderaddr[7-yy], ranx, rany, ranz);
  }}}
    }//front

  


  delay(5);//               DELAY   DELAY  DELAY
  for(xx=0; xx<8; xx++){
  LED_Old[xx]=folderaddr[xx];
  oldpullback[xx]=pullback[xx];
  }
  

  
  
 
  if(folderaddr[7]==7){
   // pullback=8;
    for(zz=0; zz<8; zz++)
  pullback[zz] = pullback[zz]+1;
 
   if(pullback[7]==8){//finished with fold
   delay(10);
     //state++;
     //if(state==4)
     //state=0;
     
     ranselect= random(3);
     if(ranselect==0){
     ranx=0;
     rany=random(1,16);
     ranz=random(1,16);}
     if(ranselect==1){
     ranx=random(1,16);
     rany=0;
     ranz=random(1,16);}
     if(ranselect==2){
     ranx=random(1,16);
     rany=random(1,16);
     ranz=0;}     
     
     side_select=random(3);
     
     if(top==1){//                 TOP
     top=0; 
     if(side==0){//top to left
      left=1;
      if(side_select==0) side=2;
      if(side_select==1) side=3;
      //if(side_select==2) side=4;
      if(side_select==2) side=5;} else    
     if(side==1){//top to right
      right=1;
      if(side_select==0) side=5;
      if(side_select==1) side=2;
      if(side_select==2) side=3;
      //if(side_select==3) side=4;
    } else  
     if(side==2){//top to back
      back=1;
      if(side_select==0) side=0;
      if(side_select==1) side=1;
      if(side_select==2) side=5;
      //if(side_select==3) side=4;
    } else      
      if(side==3){//top to front
      front=1;
      if(side_select==0) side=0;
      if(side_select==1) side=1;
      if(side_select==2) side=5;
      //if(side_select==3) side=4;
    }   
     } else//top
     if(bot==1){//                 BOTTOM
     bot=0; 
     if(side==0){//bot to left
      left=1;
      if(side_select==0) side=2;
      if(side_select==1) side=3;
      if(side_select==2) side=4;
      //if(side_select==3) side=5;
    } else    
     if(side==1){//bot to right
      right=1;
      //if(side_select==0) side=5;
      if(side_select==0) side=2;
      if(side_select==1) side=3;
      if(side_select==2) side=4;} else  
     if(side==2){//bot to back
      back=1;
      if(side_select==0) side=0;
      if(side_select==1) side=1;
      //if(side_select==2) side=5;
      if(side_select==2) side=4;} else      
      if(side==3){//bot to front
      front=1;
      if(side_select==0) side=0;
      if(side_select==1) side=1;
      //if(side_select==2) side=5;
      if(side_select==2) side=4;}   
     } else//bot
          if(right==1){//                 RIGHT
     right=0; 
     if(side==4){//right to top
      top=1;
      if(side_select==0) side=2;
      if(side_select==1) side=3;
      if(side_select==2) side=0;
      //if(side_select==3) side=1;
    } else    
     if(side==5){//right to bot
      bot=1;
      if(side_select==0) side=0;
      if(side_select==1) side=2;
      if(side_select==2) side=3;
      //if(side_select==3) side=1;
    } 
      else  
     if(side==2){//right to back
      back=1;
      if(side_select==0) side=0;
      //if(side_select==1) side=1;
      if(side_select==1) side=5;
      if(side_select==2) side=4;} else      
      if(side==3){//right to front
      front=1;
      if(side_select==0) side=0;
      //if(side_select==1) side=1;
      if(side_select==1) side=5;
      if(side_select==2) side=4;}   
     } else//bot
              if(left==1){//                 LEFT
     left=0; 
     if(side==4){//left to top
      top=1;
      //if(side_select==0) side=2;
      if(side_select==0) side=3;
      if(side_select==1) side=2;
      if(side_select==2) side=1;} else    
     if(side==5){//left to bot
      bot=1;
      //if(side_select==0) side=0;
      if(side_select==0) side=2;
      if(side_select==1) side=3;
      if(side_select==2) side=1;} else  
     if(side==2){//left to back
      back=1;
      //if(side_select==0) side=0;
      if(side_select==0) side=1;
      if(side_select==1) side=5;
      if(side_select==2) side=4;} else      
      if(side==3){//left to front
      front=1;
      //if(side_select==0) side=0;
      if(side_select==0) side=1;
      if(side_select==1) side=5;
      if(side_select==2) side=4;}   
     } else//bot
              if(front==1){//                 front
     front=0; 
     if(side==4){//front to top
      top=1;
      if(side_select==0) side=2;
      //if(side_select==1) side=3;
      if(side_select==1) side=0;
      if(side_select==2) side=1;} else    
     if(side==5){//front to bot
      bot=1;
      if(side_select==0) side=0;
      if(side_select==1) side=2;
      //if(side_select==2) side=3;
      if(side_select==2) side=1;} else  
     if(side==0){//front to left
      left=1;
      if(side_select==0) side=2;
     // if(side_select==1) side=3;
      if(side_select==1) side=5;
      if(side_select==2) side=4;} else      
      if(side==1){//front to right
      right=1;
      if(side_select==0) side=2;
     // if(side_select==1) side=3;
      if(side_select==1) side=5;
      if(side_select==2) side=4;}   
     } else//bot
              if(back==1){//                 back
     back=0; 
     if(side==4){//back to top
      top=1;
      //if(side_select==0) side=2;
      if(side_select==0) side=3;
      if(side_select==1) side=0;
      if(side_select==2) side=1;} else    
     if(side==5){//back to bot
      bot=1;
      if(side_select==0) side=0;
      //if(side_select==1) side=2;
      if(side_select==1) side=3;
      if(side_select==2) side=1;} else  
     if(side==0){//back to left
      left=1;
      //if(side_select==0) side=2;
      if(side_select==0) side=3;
      if(side_select==1) side=5;
      if(side_select==2) side=4;} else      
      if(side==1){//back to right
      right=1;
      //if(side_select==0) side=2;
      if(side_select==0) side=3;
      if(side_select==1) side=5;
      if(side_select==2) side=4;}   
     } //bot

    
      // for(yy=0; yy<8; yy++)
  //for(xx=0; xx<8; xx++)
  //LED(LED_Old[yy], xx, yy-oldpullback[yy], 0, 0, 0);
  for(xx=0; xx<8; xx++){
  oldpullback[xx]=0;
  pullback[xx]=0;}
 
  folderaddr[0]=-8;
  folderaddr[1]=-7;
  folderaddr[2]=-6;
  folderaddr[3]=-5;
  folderaddr[4]=-4;
  folderaddr[5]=-3;
  folderaddr[6]=-2;
  folderaddr[7]=-1;

}//pullback==7
  }//folderaddr==7    

  if(folderaddr[7]!=7)
  for(zz=0; zz<8; zz++)
  folderaddr[zz] = folderaddr[zz]+1;
  
}//while
  
  
  
  
  
}//folder


void bouncyvTwo(){//****bouncyTwo****bouncyTwo****bouncyTwo****bouncyTwo****bouncyTwo****bouncyTwo****bouncyTwo
  int wipex, wipey, wipez, ranr, rang, ranb, select, oldx[50], oldy[50], oldz[50];
  int x[50], y[50], z[50], addr, ledcount=20, direct, direcTwo;
  int xx[50], yy[50], zz[50];
  int xbit=1, ybit=1, zbit=1;
   for(addr=0; addr<ledcount+1; addr++){
     oldx[addr]=0;
     oldy[addr]=0;
     oldz[addr]=0;
     x[addr]=0;
     y[addr]=0;
     z[addr]=0;
     xx[addr]=0;
     yy[addr]=0;
     zz[addr]=0;
 
   }
  
      start=millis();
      
  while(millis()-start<15000){
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
    direct = random(3);

for(addr=1; addr<ledcount+1; addr++){
LED(oldx[addr], oldy[addr],oldz[addr], 0,0,0);
LED(x[addr], y[addr], z[addr], xx[addr],yy[addr],zz[addr]);
}

for(addr=1; addr<ledcount+1; addr++){
oldx[addr]=x[addr];
oldy[addr]=y[addr];
oldz[addr]=z[addr];
}
delay(20);


//direcTwo=random(3);  
//if(direcTwo==1)



if(direct==0)
x[0]= x[0]+xbit;
if(direct==1)
y[0]= y[0]+ybit;
if(direct==2)
z[0]= z[0]+zbit;

if(direct==3)
x[0]= x[0]-xbit;
if(direct==4)
y[0]= y[0]-ybit;
if(direct==5)
z[0]= z[0]-zbit;





if(x[0]>7){
xbit=-1;
x[0]=7;
xx[0]=random(16);
yy[0]=random(16);
zz[0]=0;
//wipe_out();
}
if(x[0]<0){
xbit=1;
  x[0]=0;
xx[0]=random(16);
yy[0]=0;
zz[0]=random(16);
//wipe_out();
}
if(y[0]>7){
ybit=-1;
y[0]=7;
xx[0]=0;
yy[0]=random(16);
zz[0]=random(16);
//wipe_out();
}
if(y[0]<0){
ybit=1;
  y[0]=0;
  xx[0]=0;
yy[0]=random(16);
zz[0]=random(16);
//wipe_out();
}
if(z[0]>7){
zbit=-1;
z[0]=7;
xx[0]=random(16);
yy[0]=0;
zz[0]=random(16);
//wipe_out();
}
if(z[0]<0){
zbit=1;
  z[0]=0;
  xx[0]=random(16);
yy[0]=random(16);
zz[0]=0;
//wipe_out();
}

for(addr=ledcount; addr>0; addr--){
  x[addr]=x[addr-1];
  y[addr]=y[addr-1];
  z[addr]=z[addr-1];
  xx[addr]=xx[addr-1];
  yy[addr]=yy[addr-1];
  zz[addr]=zz[addr-1];
}


  }//while
  

  
  
  
}//bouncyv2

void sinwaveTwo(){//*****sinewaveTwo*****sinewaveTwo*****sinewaveTwo*****sinewaveTwo*****sinewaveTwo*****sinewaveTwo
    int sinewavearray[8], addr, sinemult[8], colselect, rr=0, gg=0, bb=15, addrt;
  int sinewavearrayOLD[8], select, subZ=-7, subT=7, multi=0;//random(-1, 2);
  sinewavearray[0]=0;
  sinemult[0]=1;
   sinewavearray[1]=1;
  sinemult[1]=1; 
    sinewavearray[2]=2;
  sinemult[2]=1;
    sinewavearray[3]=3;
  sinemult[3]=1;
    sinewavearray[4]=4;
  sinemult[4]=1;
    sinewavearray[5]=5;
  sinemult[5]=1;
    sinewavearray[6]=6;
  sinemult[6]=1;
    sinewavearray[7]=7;
  sinemult[7]=1;
  
      start=millis();
      
  while(millis()-start<75000){
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
  for(addr=0; addr<8; addr++){
    if(sinewavearray[addr]==7){
    sinemult[addr]=-1;
    }
    if(sinewavearray[addr]==0){
    sinemult[addr]=1;     
    }
    sinewavearray[addr] = sinewavearray[addr] + sinemult[addr];
}//addr
     if(sinewavearray[0]==7){
     select=random(3);
    if(select==0){
      rr=random(1, 16);
      gg=random(1, 16);
      bb=0;} 
     if(select==1){
      rr=random(1, 16);
      gg=0;
      bb=random(1, 16);}    
     if(select==2){
      rr=0;
      gg=random(1, 16);
      bb=random(1, 16);}
   /*
 if(multi==1)
 multi=0;
 else
 multi=1;
*/

 }    
   


      for(addr=0; addr<8; addr++){
    LED(sinewavearrayOLD[addr], addr, 0, 0, 0, 0);
    LED(sinewavearrayOLD[addr], 0, addr, 0, 0, 0);
    LED(sinewavearrayOLD[addr], subT-addr, 7, 0, 0, 0);
    LED(sinewavearrayOLD[addr], 7, subT-addr, 0, 0, 0);     
   LED(sinewavearray[addr], addr, 0, rr, gg, bb);
   LED(sinewavearray[addr], 0, addr, rr, gg, bb);
   LED(sinewavearray[addr], subT-addr,7, rr, gg, bb);
   LED(sinewavearray[addr], 7, subT-addr, rr, gg, bb);
    }//}
    
       for(addr=1; addr<7; addr++){   
    LED(sinewavearrayOLD[addr+multi*1], addr, 1, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*1], 1, addr, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*1], subT-addr, 6, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*1], 6, subT-addr, 0, 0, 0);  
   LED(sinewavearray[addr+multi*1], addr, 1, rr, gg, bb);
   LED(sinewavearray[addr+multi*1], 1, addr, rr, gg, bb);
   LED(sinewavearray[addr+multi*1], subT-addr,6, rr, gg, bb);
   LED(sinewavearray[addr+multi*1], 6, subT-addr, rr, gg, bb);
       }
 
        for(addr=2; addr<6; addr++){   
    LED(sinewavearrayOLD[addr+multi*2], addr, 2, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*2], 2, addr, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*2], subT-addr, 5, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*2], 5, subT-addr, 0, 0, 0);  
   LED(sinewavearray[addr+multi*2], addr, 2, rr, gg, bb);
   LED(sinewavearray[addr+multi*2], 2, addr, rr, gg, bb);
   LED(sinewavearray[addr+multi*2], subT-addr,5, rr, gg, bb);
   LED(sinewavearray[addr+multi*2], 5, subT-addr, rr, gg, bb);
       }  
             for(addr=3; addr<5; addr++){   
    LED(sinewavearrayOLD[addr+multi*3], addr, 3, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*3], 3, addr, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*3], subT-addr, 4, 0, 0, 0);
    LED(sinewavearrayOLD[addr+multi*3], 4, subT-addr, 0, 0, 0);  
   LED(sinewavearray[addr+multi*3], addr, 3, rr, gg, bb);
   LED(sinewavearray[addr+multi*3], 3, addr, rr, gg, bb);
   LED(sinewavearray[addr+multi*3], subT-addr,4, rr, gg, bb);
   LED(sinewavearray[addr+multi*3], 4, subT-addr, rr, gg, bb);
       }      
     
     for(addr=0; addr<8; addr++)
   sinewavearrayOLD[addr]=sinewavearray[addr];
    delay(30);

    
    
  }//while
  
  
}//SinewaveTwo

void color_wheel(){
  int xx, yy, zz, ww, rr=1, gg=1, bb=1, ranx, rany, swiper;
  
        start=millis();
      
  while(millis()-start<100000){
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
    swiper=random(3);
     ranx=random(16);
     rany=random(16);
     
    for(xx=0;xx<8;xx++){
    for(yy=0;yy<8;yy++){ 
    for(zz=0;zz<8;zz++){
      
     LED(xx, yy, zz,  ranx, 0, rany);
    }}
  delay(50);
}

     ranx=random(16);
     rany=random(16);
     
    for(xx=7;xx>=0;xx--){ 
    for(yy=0;yy<8;yy++){
    for(zz=0;zz<8;zz++){
    LED(xx,yy, zz, ranx, rany, 0);
    }}
  delay(50); 
  }
       ranx=random(16);
     rany=random(16);
    for(xx=0;xx<8;xx++){ 
    for(yy=0;yy<8;yy++){
    for(zz=0;zz<8;zz++){
      LED(xx,yy, zz, 0, ranx, rany);
    }}
    delay(50);
  }
    
     ranx=random(16);
     rany=random(16);
    for(xx=7;xx>=0;xx--){ 
    for(yy=0;yy<8;yy++){
    for(zz=0;zz<8;zz++){
    LED(xx,yy, zz, rany, ranx, 0);
    }}
  delay(50); 
  }
    
  }//while
    
}//color wheel

void color_wheelTWO(){//*****colorWheelTwo*****colorWheelTwo*****colorWheelTwo*****colorWheelTwo*****colorWheelTwo
  int xx, yy, zz, ww, rr=1, gg=1, bb=1, ranx, rany ,ranz, select, swiper;
  
        start=millis();
      
  while(millis()-start<100000){
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
    swiper=random(6);
    select=random(3);
    if(select==0){
     ranx=0;
     rany=random(16);
     ranz=random(16);}
    if(select==1){
     ranx=random(16);
     rany=0;
     ranz=random(16);}   
      if(select==2){
     ranx=random(16);
     rany=random(16);
     ranz=0;}  
    
     
    if(swiper==0){
    for(yy=0;yy<8;yy++){//left to right
    for(xx=0;xx<8;xx++){
    for(zz=0;zz<8;zz++){
    LED(xx, yy, zz,  ranx, ranz, rany);
    }}
  delay(30);
 }}
    if(swiper==1){//bot to top
    for(xx=0;xx<8;xx++){
    for(yy=0;yy<8;yy++){
    for(zz=0;zz<8;zz++){
    LED(xx, yy, zz,  ranx, ranz, rany);
    }}
  delay(30);
 }}  
    if(swiper==2){//back to front
    for(zz=0;zz<8;zz++){
    for(xx=0;xx<8;xx++){
    for(yy=0;yy<8;yy++){
    LED(xx, yy, zz,  ranx, ranz, rany);
    }}
  delay(30);
}}  
    if (interrupted) {
      interruptRoutine(true);
      return;
    }  
    if(swiper==3){
    for(yy=7;yy>=0;yy--){//right to left
    for(xx=0;xx<8;xx++){
    for(zz=0;zz<8;zz++){
    LED(xx, yy, zz,  ranx, ranz, rany);
    }}
  delay(30);
}}
    if(swiper==4){//top to bot
    for(xx=7;xx>=0;xx--){
    for(yy=0;yy<8;yy++){
    for(zz=0;zz<8;zz++){
    LED(xx, yy, zz,  ranx, ranz, rany);
    }}
 delay(30);
}}  
    if(swiper==5){//front to back
    for(zz=7;zz>=0;zz--){
    for(xx=0;xx<8;xx++){
    for(yy=0;yy<8;yy++){
    LED(xx, yy, zz,  ranx, ranz, rany);
    }}
  delay(30);
}}
  
  
  
  
  }//while
    
}//color wheel

//    Harlem Shake    Harlem Shake    Harlem Shake    Harlem Shake    Harlem Shake

void harlem_shake(){
  
  
byte greenx = random(1,7),greeny = random(1,7),bluex = random(1,7),bluey = random(1,7),redx = random(1,7),redy = random(1,7);
int greenmult=1, bluemult=1, redmult=1;
int greenmulty=1, bluemulty=1, redmulty=1;
int oredx, oredy,obluex,obluey,ogreenx,ogreeny, cb1=15,cb2=0,cr1=15,cr2=0,cg1=15,cg2=0;
int time_counter=10, timemult=2;
int m;
int c1=1,c2=1,c3=1,xmult=1,ymult=1,zmult=1,x=4,y=4,z=4,color_select, xo, yo, zo;
int c21=1,c22=1,c23=1,x2mult=1,y2mult=1,z2mult=1,x2=2,y2=2,z2=2,color_select2, x2o, y2o, z2o;

int counter, i, j, k;
for(counter=0; counter<150; counter++){
  for(i=0; i<8; i++){
  LED(i,oredx,oredx,0,0,0);
  }
  for(i=0; i<8; i++){
  LED(i,redx,redx,15,0,0);
  }
  
  oredx=redx;
  oredy=redy;
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
for(i=100; i>time_counter; i--)
  delay(1);

  time_counter=time_counter+timemult;
  if(time_counter>100||time_counter<10)
  timemult=timemult*-1;


   if(redy>6 || redy<1){
  redmulty=redmulty*-1;  
  
  }
 
   if(redx>6 || redx<1){
  redmult=redmult*-1;  
  
  cr1=random(16);
  cr2=random(16);
   }

  redy=redy+redmulty;
  redx=redx+redmult;
}//counter

    if (interrupted) {
      interruptRoutine(true);
      return;
    }
for(counter=0; counter<85; counter++){
  for(i=0; i<8; i++){
  LED(i,oredx,oredx,0,0,0);
  LED(ogreenx,i,ogreeny,0,0,0);
  }
  for(i=0; i<8; i++){
  LED(i,redx,redx,15,0,0);
  LED(greenx,i,greeny,0,15,0);
  }
  ogreenx=greenx;
  ogreeny=greeny;
  oredx=redx;
  oredy=redy;
for(i=100; i>time_counter; i--)
  delay(1);

  time_counter=time_counter+timemult;
  if(time_counter>100||time_counter<10)
  timemult=timemult*-1;

   
     if(greeny>6 || greeny<1)
  greenmulty=greenmulty*-1;

   if(redy>6 || redy<1){
  redmulty=redmulty*-1;  
  
  }
 
   
     if(greenx>6 || greenx<1){
  greenmult=greenmult*-1;
  greeny = greeny + greenmulty;
  cg1=random(16);
  cg2=random(16);
  }

   if(redx>6 || redx<1){
  redmult=redmult*-1;  
  
  cr1=random(16);
  cr2=random(16);
   }
  greenx=greenx+greenmult;
  
  redy=redy+redmulty;
  redx=redx+redmult;
}//counter

    if (interrupted) {
      interruptRoutine(true);
      return;
    }
for(counter=0; counter<85; counter++){
  for(i=0; i<8; i++){
  LED(i,oredx,oredx,0,0,0);
  LED(obluey,obluex,i,0,0,0);
  LED(ogreenx,i,ogreeny,0,0,0);
  }
  for(i=0; i<8; i++){
  LED(i,redx,redx,15,0,0);
  LED(bluey,bluex,i,0,0,15);
  LED(greenx,i,greeny,0,15,0);
  }
  ogreenx=greenx;
  ogreeny=greeny;
  obluex=bluex;
  obluey=bluey;
  oredx=redx;
  oredy=redy;
for(i=100; i>time_counter; i--)
  delay(1);

  time_counter=time_counter+timemult;
  if(time_counter>100||time_counter<10)
  timemult=timemult*-1;

   
     if(greeny>6 || greeny<1)
  greenmulty=greenmulty*-1;

   if(bluey>6 || bluey<1)
  bluemulty=bluemulty*-1;

   if(redy>6 || redy<1){
  redmulty=redmulty*-1;  
  
  }
 
    if (interrupted) {
      interruptRoutine(true);
      return;
    }   
     if(greenx>6 || greenx<1){
  greenmult=greenmult*-1;
  greeny = greeny + greenmulty;
  cg1=random(16);
  cg2=random(16);
  }
   if(bluex>6 || bluex<1){
  bluemult=bluemult*-1;
  bluey=bluey+bluemulty;
  cb1=random(16);
  cb2=random(16);
   }
   if(redx>6 || redx<1){
  redmult=redmult*-1;  
  
  cr1=random(16);
  cr2=random(16);
   }
  greenx=greenx+greenmult;
  bluex=bluex+bluemult;
  redy=redy+redmulty;
  redx=redx+redmult;
}//counter


    if (interrupted) {
      interruptRoutine(true);
      return;
    }
for(counter=0; counter<3; counter++){ // counter was 3
  for(i=0; i<8; i++)
  for(j=0; j<8; j++)
  for(k=0; k<8; k++)
  LED(i,j,k,8,15,15);// red too intense to make white at 15. Reduced to 8 - makes nice white level.
  delay(50);
  for(i=0; i<8; i++)
  for(j=0; j<8; j++)
  for(k=0; k<8; k++)
  LED(i,j,k,0,0,0);
  delay(50);
}//counter
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
  for(m=0; m<1; m++){
    
    
  for(i=0; i<8; i++)
  for(j=0; j<8; j++)
  for(k=0; k<8; k++)
  LED(i,j,k,0,random(16),random(16));

  for(i=7; i>=0; i--)
  for(j=0; j<8; j++)
  for(k=0; k<8; k++)
  LED(i,j,k,random(16),0,random(16));

  for(i=0; i<8; i++)
  for(j=0; j<8; j++)
  for(k=0; k<8; k++)
  LED(i,j,k,random(16),random(16),0);

  for(i=7; i>=0; i--)
  for(j=0; j<8; j++)
  for(k=0; k<8; k++)
  LED(i,j,k,random(16),0,random(16));
  }
    if (interrupted) {
      interruptRoutine(true);
      return;
    }
clean(); 
// this is the random changing led colour full cube


for(m=0; m<20; m++){
    for(k=0; k<200; k++){
  LED(random(8),random(8),random(8),random(16),random(16),0);
  LED(random(8),random(8),random(8),random(16),0 ,random(16));
  LED(random(8),random(8),random(8),0, random(16),random(16));
   //   c1=random(8);
     // c2=random(8);
      //c3=random(8);
  //LED(c1,c2,c3,15,15,15);
  }
      for(k=0; k<200; k++){
  LED(random(8),random(8),random(8),0,0,0);
  }
  
}//m


  
  
clean();

color_select=random(0,3);
if(color_select==0){
c1 = 0;
c2 = random(0,16);
c3 = random(0,16);}
if(color_select==1){
c1 = random(0,16);
c2 = 0;
c3 = random(0,16);}
if(color_select==2){
c1 = random(0,16);
c2 = random(0,16);
c3 = 0;}


color_select2=random(0,3);
if(color_select2==0){
c21 = 0;
c22 = random(0,16);
c23 = random(0,16);}
if(color_select2==1){
c21 = random(0,16);
c22 = 0;
c23 = random(0,16);}
if(color_select2==2){
c21 = random(0,16);
c22 = random(0,16);
c23 = 0;}

 for(counter=0; counter<200; counter++){

LED(xo,yo,zo,0,0,0);
LED(xo+1,yo,zo,0,0,0);
LED(xo+2,yo,zo,0,0,0);
LED(xo-1,yo,zo,0,0,0);
LED(xo-2,yo,zo,0,0,0);
LED(xo,yo+1,zo,0,0,0);
LED(xo,yo-1,zo,0,0,0);
LED(xo,yo+2,zo,0,0,0);
LED(xo,yo-2,zo,0,0,0);
LED(xo,yo,zo-1,0,0,0);
LED(xo,yo,zo+1,0,0,0);
LED(xo,yo,zo-2,0,0,0);
LED(xo,yo,zo+2,0,0,0);

LED(x2o,y2o,z2o,0,0,0);
LED(x2o+1,y2o,z2o,0,0,0);
LED(x2o+2,y2o,z2o,0,0,0);
LED(x2o-1,y2o,z2o,0,0,0);
LED(x2o-2,y2o,z2o,0,0,0);
LED(x2o,y2o+1,z2o,0,0,0);
LED(x2o,y2o-1,z2o,0,0,0);
LED(x2o,y2o+2,z2o,0,0,0);
LED(x2o,y2o-2,z2o,0,0,0);
LED(x2o,y2o,z2o-1,0,0,0);
LED(x2o,y2o,z2o+1,0,0,0);
LED(x2o,y2o,z2o-2,0,0,0);
LED(x2o,y2o,z2o+2,0,0,0);

LED(xo+1,yo+1,zo,0,0,0);
LED(xo+1,yo-1,zo,0,0,0);
LED(xo-1,yo+1,zo,0,0,0);
LED(xo-1,yo-1,zo,0,0,0);
LED(xo+1,yo+1,zo+1,0,0,0);
LED(xo+1,yo-1,zo+1,0,0,0);
LED(xo-1,yo+1,zo+1,0,0,0);
LED(xo-1,yo-1,zo+1,0,0,0);
LED(xo+1,yo+1,zo-1,0,0,0);
LED(xo+1,yo-1,zo-1,0,0,0);
LED(xo-1,yo+1,zo-1,0,0,0);
LED(xo-1,yo-1,zo-1,0,0,0);

LED(x2o+1,y2o+1,z2o,0,0,0);
LED(x2o+1,y2o-1,z2o,0,0,0);
LED(x2o-1,y2o+1,z2o,0,0,0);
LED(x2o-1,y2o-1,z2o,0,0,0);
LED(x2o+1,y2o+1,z2o+1,0,0,0);
LED(x2o+1,y2o-1,z2o+1,0,0,0);
LED(x2o-1,y2o+1,z2o+1,0,0,0);
LED(x2o-1,y2o-1,z2o+1,0,0,0);
LED(x2o+1,y2o+1,z2o-1,0,0,0);
LED(x2o+1,y2o-1,z2o-1,0,0,0);
LED(x2o-1,y2o+1,z2o-1,0,0,0);
LED(x2o-1,y2o-1,z2o-1,0,0,0);

LED(x,y,z,c1,c2,c3);
LED(x,y,z-1,c1,c2,c3);
LED(x,y,z+1,c1,c2,c3);
LED(x,y,z-2,c1,c2,c3);
LED(x,y,z+2,c1,c2,c3);
LED(x+1,y,z,c1,c2,c3);
LED(x-1,y,z,c1,c2,c3);
LED(x,y+1,z,c1,c2,c3);
LED(x,y-1,z,c1,c2,c3);
LED(x+2,y,z,c1,c2,c3);
LED(x-2,y,z,c1,c2,c3);
LED(x,y+2,z,c1,c2,c3);
LED(x,y-2,z,c1,c2,c3);
LED(x+1,y+1,z,c1,c2,c3);
LED(x+1,y-1,z,c1,c2,c3);
LED(x-1,y+1,z,c1,c2,c3);
LED(x-1,y-1,z,c1,c2,c3);
LED(x+1,y+1,z+1,c1,c2,c3);
LED(x+1,y-1,z+1,c1,c2,c3);
LED(x-1,y+1,z+1,c1,c2,c3);
LED(x-1,y-1,z+1,c1,c2,c3);
LED(x+1,y+1,z-1,c1,c2,c3);
LED(x+1,y-1,z-1,c1,c2,c3);
LED(x-1,y+1,z-1,c1,c2,c3);
LED(x-1,y-1,z-1,c1,c2,c3);

LED(x2,y2,z2,c21,c22,c23);
LED(x2,y2,z2-1,c21,c22,c23);
LED(x2,y2,z2+1,c21,c22,c23);
LED(x2,y2,z2-2,c21,c22,c23);
LED(x2,y2,z2+2,c21,c22,c23);
LED(x2+1,y2,z2,c21,c22,c23);
LED(x2-1,y2,z2,c21,c22,c23);
LED(x2,y2+1,z2,c21,c22,c23);
LED(x2,y2-1,z2,c21,c22,c23);
LED(x2+2,y2,z2,c21,c22,c23);
LED(x2-2,y2,z2,c21,c22,c23);
LED(x2,y2+2,z2,c21,c22,c23);
LED(x2,y2-2,z2,c21,c22,c23);
LED(x2+1,y2+1,z2,c21,c22,c23);
LED(x2+1,y2-1,z2,c21,c22,c23);
LED(x2-1,y2+1,z2,c21,c22,c23);
LED(x2-1,y2-1,z2,c21,c22,c23);
LED(x2+1,y2+1,z2+1,c21,c22,c23);
LED(x2+1,y2-1,z2+1,c21,c22,c23);
LED(x2-1,y2+1,z2+1,c21,c22,c23);
LED(x2-1,y2-1,z2+1,c21,c22,c23);
LED(x2+1,y2+1,z2-1,c21,c22,c23);
LED(x2+1,y2-1,z2-1,c21,c22,c23);
LED(x2-1,y2+1,z2-1,c21,c22,c23);
LED(x2-1,y2-1,z2-1,c21,c22,c23);

    if (interrupted) {
      interruptRoutine(true);
      return;
    }


x2o=x2;
y2o=y2;
z2o=z2;

xo=x;
yo=y;
zo=z;

delay(45);

x = x+xmult;
y= y+ymult;
z= z+zmult;

x2 = x2+x2mult;
y2= y2+y2mult;
z2= z2+z2mult;

if(x>=7){
//x=7;
xmult=random(-1,1);
}
if(y>=7){
//y=7;
ymult=random(-1,1);}
if(z>=7){
//z=7;
zmult=random(-1,1);}
if(x<=0){
//x=0;
xmult=random(0,2);}
if(y<=0){
//y=0;
ymult=random(0,2);}
if(z<=0){
//z=0;
zmult=random(0,2);
}

if(x2>=7){
//x=7;
x2mult=random(-1,1);
}
if(y2>=7){
//y=7;
y2mult=random(-1,1);}
if(z2>=7){
//z=7;
z2mult=random(-1,1);}
if(x2<=0){
//x=0;
x2mult=random(0,2);}
if(y2<=0){
//y=0;
y2mult=random(0,2);}
if(z<=0){
//z=0;
z2mult=random(0,2);
}




}//counter  counter counter counter counter


for(counter=0; counter<15; counter++){
  color_select=random(0,3);
if(color_select==0){
c1 = 0;
c2 = random(0,16);
c3 = random(0,16);}
if(color_select==1){
c1 = random(0,16);
c2 = 0;
c3 = random(0,16);}
if(color_select==2){
c1 = random(0,16);
c2 = random(0,16);
c3 = 0;}
  
    if (interrupted) {
      interruptRoutine(true);
      return;
    }  
int num1=-1, num2=-4, num3=-6, num4=-10;
for(m=0; m<20; m++){
  
num1++;
num2++;
num3++;
num4++;

for(i=3; i<5; i++){
LED(num1, i,3,0,0,0);
LED(num1, 3,i,0,0,0);
LED(num1, 4,i,0,0,0);
LED(num1, i,4,0,0,0);
}
for(i=3; i<5; i++){
LED(num1+1, i,4,c1,c2,c3);
LED(num1+1, 4,i,c1,c2,c3);
LED(num1+1, 3,i,c1,c2,c3);
LED(num1+1, i,3,c1,c2,c3);
}
for(i=2; i<6; i++){
LED(num2, i,2,0,0,0);
LED(num2, 2,i,0,0,0);
LED(num2, 5,i,0,0,0);
LED(num2, i,5,0,0,0);
}
for(i=2; i<6; i++){
LED(num2+1, i,2,c1,c2,c3);
LED(num2+1, 2,i,c1,c2,c3);
LED(num2+1, 5,i,c1,c2,c3);
LED(num2+1, i,5,c1,c2,c3);
}
for(i=1; i<7; i++){
LED(num3, i,1,0,0,0);
LED(num3, 1,i,0,0,0);
LED(num3, 6,i,0,0,0);
LED(num3, i,6,0,0,0);
}
for(i=1; i<7; i++){
LED(num3+1, i,1,c1,c2,c3);
LED(num3+1, 1,i,c1,c2,c3);
LED(num3+1, 6,i,c1,c2,c3);
LED(num3+1, i,6,c1,c2,c3);
}
for(i=0; i<8; i++){
LED(num4, i,0,0,0,0);
LED(num4, 0,i,0,0,0);
LED(num4, 7,i,0,0,0);
LED(num4, i,7,0,0,0);
}
for(i=0; i<8; i++){
LED(num4+1, i,0,c1,c2,c3);
LED(num4+1, 0,i,c1,c2,c3);
LED(num4+1, 7,i,c1,c2,c3);
LED(num4+1, i,7,c1,c2,c3);
}
//delay(1);
}//m
num1=8;
num2=11;
num3=13;
num4=17;

for(m=0; m<20; m++){
num1--;
num2--;
num3--;
num4--;
for(i=3; i<5; i++){
LED(num1, i,3,0,0,0);
LED(num1, 3,i,0,0,0);
LED(num1, 4,i,0,0,0);
LED(num1, i,4,0,0,0);
}
for(i=3; i<5; i++){
LED(num1-1, i,4,0,0,15);
LED(num1-1, 4,i,0,0,15);
LED(num1-1, 3,i,0,0,15);
LED(num1-1, i,3,0,0,15);
}
for(i=2; i<6; i++){
LED(num2, i,2,0,0,0);
LED(num2, 2,i,0,0,0);
LED(num2, 5,i,0,0,0);
LED(num2, i,5,0,0,0);
}
for(i=2; i<6; i++){
LED(num2-1, i,2,0,0,15);
LED(num2-1, 2,i,0,0,15);
LED(num2-1, 5,i,0,0,15);
LED(num2-1, i,5,0,0,15);
}
for(i=1; i<7; i++){
LED(num3, i,1,0,0,0);
LED(num3, 1,i,0,0,0);
LED(num3, 6,i,0,0,0);
LED(num3, i,6,0,0,0);
}
for(i=1; i<7; i++){
LED(num3-1, i,1,0,0,15);
LED(num3-1, 1,i,0,0,15);
LED(num3-1, 6,i,0,0,15);
LED(num3-1, i,6,0,0,15);
}
for(i=0; i<8; i++){
LED(num4, i,0,0,0,0);
LED(num4, 0,i,0,0,0);
LED(num4, 7,i,0,0,0);
LED(num4, i,7,0,0,0);
}
for(i=0; i<8; i++){
LED(num4-1, i,0,0,0,15);
LED(num4-1, 0,i,0,0,15);
LED(num4-1, 7,i,0,0,15);
LED(num4-1, i,7,0,0,15);
}
//delay(1);
}//m

}//counter

}//harlem SHake

void CopyIntMatrix(int* A, int n, int m, int* B)
{
  int i, j, k;
  for (i = 0; i < m; i++)
    for(j = 0; j < n; j++)
    {
    
      B[n * i + j] = A[n * i + j];
    }
}

void CopyFloatMatrix(float* A, int n, int m, float* B)
{
  int i, j, k;
  for (i = 0; i < m; i++)
    for(j = 0; j < n; j++)
    {
    
      B[n * i + j] = A[n * i + j];
    }
}
void MultiplyIntMatrix(int* A, int* B, int m, int p, int n, int* C)
{
  // A = input matrix (m x p)
  // B = input matrix (p x n)
  // m = number of rows in A
  // p = number of columns in A = number of rows in B
  // n = number of columns in B
  // C = output matrix = A*B (m x n)
  int i, j, k;
  for (i = 0; i < m; i++)
    for(j = 0; j < n; j++)
    {
      C[n * i + j] = 0;
      for (k = 0; k < p; k++)
        C[n * i + j] = C[n * i + j] + A[p * i + k] * B[n * k + j];
    }
}
//exactly like MultiplyIntMatrix except it gets the values of matrix B via PROGMEM recall. This is to save memory
void MultiplyIntMatrixPROGMEM(int* A, int* B, int m, int p, int n, int* C)
{
  // A = input matrix (m x p)
  // B = input matrix (p x n)
  // m = number of rows in A
  // p = number of columns in A = number of rows in B
  // n = number of columns in B
  // C = output matrix = A*B (m x n)
  int i, j, k;
  for (i = 0; i < m; i++)
    for(j = 0; j < n; j++)
    {
      C[n * i + j] = 0;
      for (k = 0; k < p; k++)
        C[n * i + j] = C[n * i + j] + A[p * i + k] * pgm_read_word_near(&B[n * k + j]);
    }
}
void MultiplyFloatMatrix(float* A, float* B, int m, int p, int n, float* C)
{
  // A = input matrix (m x p)
  // B = input matrix (p x n)
  // m = number of rows in A
  // p = number of columns in A = number of rows in B
  // n = number of columns in B
  // C = output matrix = A*B (m x n)
  int i, j, k;
  for (i = 0; i < m; i++)
    for(j = 0; j < n; j++)
    {
      C[n * i + j] = 0;
      for (k = 0; k < p; k++)
        C[n * i + j] = C[n * i + j] + A[p * i + k] * B[n * k + j];
    }
}
//a hacky function to save memory. Multiplys a float matrix A with a PROGMEM float matrix B
void MultiplyFloatMatrixPROGMEM(float* A, float* B, int m, int p, int n, float* C)
{
  // A = input matrix (m x p)
  // B = input matrix (p x n)
  // m = number of rows in A
  // p = number of columns in A = number of rows in B
  // n = number of columns in B
  // C = output matrix = A*B (m x n)
  int i, j, k;
  for (i = 0; i < m; i++)
    for(j = 0; j < n; j++)
    {
      C[n * i + j] = 0;
      for (k = 0; k < p; k++)
        C[n * i + j] = C[n * i + j] + A[p * i + k] * pgm_read_float_near(&B[n * k + j]);
    }
}
//a hacky function to save memory. Multiplys an int matrix A with a PROGMEM float matrix B
void MultiplyIntAndFloatMatrixPROGMEM(int* A, float* B, int m, int p, int n, float* C)
{
  // A = input matrix (m x p)
  // B = input matrix (p x n)
  // m = number of rows in A
  // p = number of columns in A = number of rows in B
  // n = number of columns in B
  // C = output matrix = A*B (m x n)
  int i, j, k;
  for (i = 0; i < m; i++)
    for(j = 0; j < n; j++)
    {
      C[n * i + j] = 0;
      for (k = 0; k < p; k++)
        C[n * i + j] = C[n * i + j] + (float)A[p * i + k] * pgm_read_float_near(&B[n * k + j]);
    }
}

void clean(){
  int ii, jj, kk;
    for(ii=0; ii<8; ii++)
  for(jj=0; jj<8; jj++)
  for(kk=0; kk<8; kk++)
  LED(ii,jj,kk,0,0,0);
  
}
void interruptRoutine(bool resetInterrupt){
  if (resetInterrupt)
    interrupted = false;
  if (settingChange) {
    settingChange = false;
    String myChar;
    myChar=settingNames[currentSetting];
    displaySingleChar(myChar[0], 500,8, 15, 15);
    currentRoutine--;
  } else if (factorChange) {
    factorChange = false;
    String myChar;
    myChar=String(routineSettings[currentRoutine][currentSetting]);
    displaySingleChar(myChar[0], 500,8, 15, 15);
    currentRoutine--;
  }
  clean();
}

void displaySolidText(String s, int delayms,int R, int G, int B) {
  for (char c : s) {
    displaySolidLetter(c,R,G,B);
    delay(delayms);
  }
  displaySolidLetter(' ',R,G,B);
  delay(delayms);
}
void displayTextRoutine(int* settings) {
  for (int i = 0; i < pow(2,settings[0]+1);i++) {
     if (interrupted) {
      interruptRoutine(true);
      return;
    }
    if (settings[1]-6 < 0)
    settings[1] = 6;
    displayScrollingRandomText();
//    switch (settings[2]) {
//      case 0:
//      {
//        displayScrollingRandomText();
//        break;
//      }
//      case 1:
//      {
//        displayScrollingColoredText(messages[settings[1]-6],settings[3]);
//        break;
//      }
//      case 2:
//      {
//        displaySolidColoredText(messages[settings[1]-6],2000,settings[3]);
//        break;
//      }
//      case 3:
//      {
//        displayScrollingText(messages[settings[1]-6],random(16),random(16),random(16));
//        break;
//      }
//      case 4:
//      {
//        displaySolidText(messages[settings[1]-6],2000,random(16),random(16),random(16));
//        break;
//      }
//      default:
//      {
//        displayScrollingColoredText(messages[settings[1]-6],settings[3]);
//        break;
//      }
//    }
  }
  
}
void displaySolidColoredText(String s, int delayms, int colorSet) {
  for (char c : s) {
    displaySolidColoredLetter(c,colorSet);
    if (interrupted) {
      interruptRoutine(false);
      return;
    }
    delay(delayms);
  }
  displaySolidLetter(' ',0,0,0);
  delay(delayms);
}
void displaySingleChar(char c, int delayms,int R, int G, int B) {
  displaySolidLetter(c,R,G,B);
  delay(delayms);
  clean();
}

void displayScrollingText(String s,int R, int G, int B) {
  for (char c : s) {
    displayScrollingLetter(c,R,G,B);
     if (interrupted) {
      interruptRoutine(false);
      return;
    }
  }
}
void displayScrollingColoredText(String s,int colorSet) {
  for (char c : s) {
    displayScrollingColoredLetter(c,colorSet);
     if (interrupted) {
      interruptRoutine(false);
      return;
    }
  }
}
void displayScrollingRandomText() {
  String s = messages[random(numberOfMessages)];
  byte color = random(numberOfColorSets);
  for (char c : s) {
    displayScrollingColoredLetter(c,color);
    clean();
     if (interrupted) {
      interruptRoutine(false);
      return;
    }
  }
}


void displaySolidLetter(char c,int R, int G, int B) {
  //LED(int level, int row, int column, byte red, byte green, byte blue)
  char display[8];// = font_data[c];
  int j = 7;
  for (int i = 0; i < 8; i++) {
    //display[0] = 0x00;
    display[i] = pgm_read_word_near(&font_data[c][j]);
    j--;
  }
  for (int level = 0; level < 8; level++) {
    int row = 0;
    //reverseCounter is used to horizonally flip the chars on opposite sides of the cube
    int reverseCounter = 7;
    for (unsigned int mask = 0x80; mask != 0; mask >>= 1) {
        if (display[level] & mask) {
          //bit is 1
            LED(level,row,0,R,G,B);
            LED(level,reverseCounter,7,R,G,B);
            LED(level,0,reverseCounter,R,G,B);
            LED(level,7,row,R,G,B);
        }
        else {
            // bit is 0
            LED(level,row,0,0,0,0);
            LED(level,reverseCounter,7,0,0,0);
            LED(level,0,reverseCounter,0,0,0);
            LED(level,7,row,0,0,0);
        }
        row++;
        reverseCounter--;
    }
  }
 }
 void displaySolidColoredLetter(char c,int colorSet) {
  char display[8];// = font_data[c];
  int j = 7;
  for (int i = 0; i < 8; i++) {
    //display[0] = 0x00;
    display[i] = pgm_read_word_near(&font_data[c][j]);
    j--;
  }
  for (int level = 0; level < 8; level++) {
    int row = 0;
    //reverseCounter is used to horizonally flip the chars on opposite sides of the cube
    int reverseCounter = 7;
    for (unsigned int mask = 0x80; mask != 0; mask >>= 1) {
        if (display[level] & mask) {
          //bit is 1
            LED(level,row,0,pgm_read_word_near(&colorSets[colorSet][level][0]),pgm_read_word_near(&colorSets[colorSet][level][1]),pgm_read_word_near(&colorSets[colorSet][level][2]));
            LED(level,reverseCounter,7,pgm_read_word_near(&colorSets[colorSet][level][0]),pgm_read_word_near(&colorSets[colorSet][level][1]),pgm_read_word_near(&colorSets[colorSet][level][2]));
            LED(level,0,reverseCounter,pgm_read_word_near(&colorSets[colorSet][level][0]),pgm_read_word_near(&colorSets[colorSet][level][1]),pgm_read_word_near(&colorSets[colorSet][level][2]));
            LED(level,7,row,pgm_read_word_near(&colorSets[colorSet][level][0]),pgm_read_word_near(&colorSets[colorSet][level][1]),pgm_read_word_near(&colorSets[colorSet][level][2]));
        }
        else {
            // bit is 0
            LED(level,row,0,0,0,0);
            LED(level,reverseCounter,7,0,0,0);
            LED(level,0,reverseCounter,0,0,0);
            LED(level,7,row,0,0,0);
        }
        row++;
        reverseCounter--;
    }
  }
 }

void displayScrollingLetter(char c, int R, int G, int B) { 
  Serial.println("displaying letteR");
  char letter[8];
  int j = 7;
  for (int i = 0; i < 8; i++) {
    letter[i] = pgm_read_word_near(&font_data[c][j--]);
  }
  int pointCounter = 0;
  //counts how many points this char has
  for (int level = 0; level < 8; level++) {
      for (unsigned int mask = 0x80; mask != 0; mask >>= 1) {
          if (letter[level] & mask) {
            pointCounter++;
          }
      }
    }
    byte pointsArray[pointCounter][4];
    pointCounter = 0;
    for (int level = 0; level < 8; level++) {
        int row = 0;
        for (unsigned int mask = 0x80; mask != 0; mask >>= 1) {
            if (letter[level] & mask) {
                pointsArray[pointCounter][0] = (byte)level;
                pointsArray[pointCounter][1] = (byte)row; 
                pointsArray[pointCounter][2] = (byte)0;
                pointsArray[pointCounter++][3] = (byte)1;
            }
            row++;
        }
      }
      int currentFrame[scrollingTextTransformObjects][pointCounter][4], previousFrame[scrollingTextTransformObjects][pointCounter][4];
      for (int steps = 0; steps < scrollingTextTransformSteps; steps++) {
        for (int transformObjects = 0 ; transformObjects < scrollingTextTransformObjects; transformObjects++) {
        if (steps == 0) {
          MultiplyIntMatrixPROGMEM((int*)pointsArray, (int*)scrollingTextTransform[transformObjects][steps], pointCounter, 4, 4, (int*)currentFrame[transformObjects]);
          CopyIntMatrix((int*)currentFrame[transformObjects], pointCounter, 4, (int*)previousFrame[transformObjects]);   
        } else {
          CopyIntMatrix((int*)currentFrame[transformObjects], pointCounter, 4, (int*)previousFrame[transformObjects]);
          MultiplyIntMatrixPROGMEM((int*)pointsArray, (int*)scrollingTextTransform[transformObjects][steps], pointCounter, 4, 4, (int*)currentFrame[transformObjects]);
        }
        for (int pointNo = 0; pointNo < pointCounter; pointNo++) {
          if (previousFrame[transformObjects][pointNo][0] >= 0 && previousFrame[transformObjects][pointNo][0] < 8 && previousFrame[transformObjects][pointNo][1] >= 0 && previousFrame[transformObjects][pointNo][1] < 8 && previousFrame[transformObjects][pointNo][2] >= 0 && previousFrame[transformObjects][pointNo][2] < 8) {
            LED((int)previousFrame[transformObjects][pointNo][0],(int)previousFrame[transformObjects][pointNo][1],(int)previousFrame[transformObjects][pointNo][2],0,0,0);
          }
        }
        for (int pointNo = 0; pointNo < pointCounter; pointNo++) {
          if (currentFrame[transformObjects][pointNo][0] >= 0 && currentFrame[transformObjects][pointNo][0] < 8 && currentFrame[transformObjects][pointNo][1] >= 0 && currentFrame[transformObjects][pointNo][1] < 8 && currentFrame[transformObjects][pointNo][2] >= 0 && currentFrame[transformObjects][pointNo][2] < 8) {
            LED((int)currentFrame[transformObjects][pointNo][0],(int)currentFrame[transformObjects][pointNo][1],(int)currentFrame[transformObjects][pointNo][2],R,G,B);
          }
        }
      }

      delay(150);
    }
 }
 void displayScrollingColoredLetter(char c, int colorSet) { 
  char letter[8];
  int j = 7;
  for (int i = 0; i < 8; i++) {
    letter[i] = pgm_read_word(&font_data[c][j--]);
  }
  int pointCounter = 0;
  //counts how many points this char has
  for (int level = 0; level < 8; level++) {
      for (unsigned int mask = 0x80; mask != 0; mask >>= 1) {
          if (letter[level] & mask) {
            pointCounter++;
          }
      }
    }
    int pointsArray[pointCounter][4];
    pointCounter = 0;
    for (int level = 0; level < 8; level++) {
        int row = 0;
        for (unsigned int mask = 0x80; mask != 0; mask >>= 1) {
            if (letter[level] & mask) {
                pointsArray[pointCounter][0] = level;
                pointsArray[pointCounter][1] = row; 
                pointsArray[pointCounter][2] = 0;
                pointsArray[pointCounter++][3] = 1;
            }
            row++;
        }
      }
      int currentFrame[scrollingTextTransformObjects][pointCounter][4], previousFrame[scrollingTextTransformObjects][pointCounter][4];
      for (int steps = 0; steps < scrollingTextTransformSteps; steps++) {
        for (int transformObjects = 0 ; transformObjects < scrollingTextTransformObjects; transformObjects++) {
        if (steps == 0) {
          MultiplyIntMatrixPROGMEM((int*)pointsArray, (int*)scrollingTextTransform[transformObjects][steps], pointCounter, 4, 4, (int*)currentFrame[transformObjects]);
          CopyIntMatrix((int*)currentFrame[transformObjects], pointCounter, 4, (int*)previousFrame[transformObjects]);   
        } else {
          CopyIntMatrix((int*)currentFrame[transformObjects], pointCounter, 4, (int*)previousFrame[transformObjects]);
          MultiplyIntMatrixPROGMEM((int*)pointsArray, (int*)scrollingTextTransform[transformObjects][steps], pointCounter, 4, 4, (int*)currentFrame[transformObjects]);
        }
        for (int pointNo = 0; pointNo < pointCounter; pointNo++) {
          if (previousFrame[transformObjects][pointNo][0] >= 0 && previousFrame[transformObjects][pointNo][0] < 8 && previousFrame[transformObjects][pointNo][1] >= 0 && previousFrame[transformObjects][pointNo][1] < 8 && previousFrame[transformObjects][pointNo][2] >= 0 && previousFrame[transformObjects][pointNo][2] < 8) {
            LED((int)previousFrame[transformObjects][pointNo][0],(int)previousFrame[transformObjects][pointNo][1],(int)previousFrame[transformObjects][pointNo][2],0,0,0);
          }
        }
        for (int pointNo = 0; pointNo < pointCounter; pointNo++) {
          if (currentFrame[transformObjects][pointNo][0] >= 0 && currentFrame[transformObjects][pointNo][0] < 8 && currentFrame[transformObjects][pointNo][1] >= 0 && currentFrame[transformObjects][pointNo][1] < 8 && currentFrame[transformObjects][pointNo][2] >= 0 && currentFrame[transformObjects][pointNo][2] < 8) {
            LED((int)currentFrame[transformObjects][pointNo][0],(int)currentFrame[transformObjects][pointNo][1],(int)currentFrame[transformObjects][pointNo][2],pgm_read_word_near(&colorSets[colorSet][(int)currentFrame[transformObjects][pointNo][0]][0]),pgm_read_word_near(&colorSets[colorSet][(int)currentFrame[transformObjects][pointNo][0]][1]),pgm_read_word_near(&colorSets[colorSet][(int)currentFrame[transformObjects][pointNo][0]][2]));
          }
        }
        
      }
      delay(150);
    }
 }
 void transformAndDisplayObject(int* pointsMatrix, int pointCounter, int* transformMatrix, int R, int G, int B) { 
  int transformedObject[pointCounter][4];
  MultiplyIntMatrix((int*)pointsMatrix, (int*)transformMatrix, pointCounter, 4, 4, (int*)transformedObject);
  for (int pointNo = 0; pointNo < pointCounter; pointNo++) {
    //if point is out of bounds, don't display it
    if (transformedObject[pointNo][0] >= 0 && transformedObject[pointNo][0] < 8 && transformedObject[pointNo][1] >= 0 && transformedObject[pointNo][1] < 8 && transformedObject[pointNo][2] >= 0 && transformedObject[pointNo][2] < 8) {
      LED(transformedObject[pointNo][0],transformedObject[pointNo][1],transformedObject[pointNo][2],R,G,B);
    } else {
      //Serial.print("Not displaying point ");Serial.print(transformedObject[pointNo][0]);Serial.print(",");Serial.print(transformedObject[pointNo][1]);Serial.print(",");Serial.print(transformedObject[pointNo][2]);Serial.println(" Cause OOB");
    }
  }
  CopyIntMatrix((int*)transformedObject, pointCounter, 4, (int*)pointsMatrix);
}
void displayObject(float* pointsMatrix, int pointCounter, int R, int G, int B) {
  float object[pointCounter][4];
  CopyFloatMatrix((float*)pointsMatrix, pointCounter, 4, (float*)object);
  for (int pointNo = 0; pointNo < pointCounter; pointNo++) {
    //if point is out of bounds, don't display it
    if (object[pointNo][0] >= 0 && object[pointNo][0] < 8 && object[pointNo][1] >= 0 && object[pointNo][1] < 8 && object[pointNo][2] >= 0 && object[pointNo][2] < 8) {
      LED(object[pointNo][0],object[pointNo][1],object[pointNo][2],R,G,B);
    }
  }
}
//this function takes a points and adjacency matrix and displays the lines in between the points according to the adjacency matrix
void drawLines(float* pointsMatrix, int* adjacencyMatrix, int pointCounter, int R, int G, int B) {
  float points[pointCounter][4];
  CopyFloatMatrix((float*)pointsMatrix, pointCounter, 4, (float*)points);
  int adjacency[pointCounter][pointCounter];
  CopyIntMatrix((int*)adjacencyMatrix, pointCounter, pointCounter, (int*)adjacency);
  for (int i = 0; i < pointCounter; i++) {
    for (int j = 0; j < pointCounter; j++) {
      if (adjacency[i][j]) {
        int pointsInLine = 8;
        for (int p = 0; p < pointsInLine; p++) {
          float t = (float)p/pointsInLine;
          LED(points[i][0] + (points[j][0]-points[i][0])*t,points[i][1] + (points[j][1]-points[i][1])*t,points[i][2] + (points[j][2]-points[i][2])*t,R,G,B);
        }
      }
    }
  }
}

